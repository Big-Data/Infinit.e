<?xml version="1.0" encoding="utf-8"?>
<!--

The MIT License
Copyright (c) 2011 IKANOW llc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-->

<mx:Module xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:actionscript="com.ikanow.infinit.e.actionscript.*"
	xmlns:components="com.ikanow.infinit.e.components.*"
	xmlns:framework="com.ikanow.infinit.e.widget.library.framework.*"
	xmlns:ilog="http://www.ilog.com/2007/ilog/flex"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	layout="absolute"
	implements="com.ikanow.infinit.e.widget.library.widget.IWidget"
	creationComplete="{ try { onWidgetCreationComplete(); } catch (e:Error) {  }  dispatchEvent(new Event('Done Loading')); }">

	<!-- 1] GUI declaration -->

	<s:VGroup 
		width="100%"
		height="100%"
		x="0"
		y="0"
		horizontalAlign="center"
		gap="0"
		includeIn="dataview">

		<!-- Toolbar -->

		<mx:ApplicationControlBar 
			width="100%"
			fillAlphas="[1.0, 1.0]"
			fillColors="[#838080, #050505]">
			<s:HGroup 
				width="100%"
				horizontalAlign="left"
				left="10"
				top="10"
				verticalAlign="middle">
				<s:Button id="_localFilterSettings"
					toolTip="Ignore Internal Filtering"
					click="onClickIgnoreLocalFilter()"
					skinClass="com.ikanow.infinit.e.skins.InfiniteFilterApplyOrIgnore" />
				<mx:MenuBar id="_filterMenu"
					labelField="@label"
					menuBarItemRenderer="com.ikanow.infinit.e.skins.InfiniteMenuBarItem"
					backgroundSkin="com.ikanow.infinit.e.skins.MenuBarSkin"
					itemDownSkin="com.ikanow.infinit.e.skins.ActivatorSkin"
					itemOverSkin="com.ikanow.infinit.e.skins.ActivatorSkin"
					itemUpSkin="com.ikanow.infinit.e.skins.ActivatorSkin"
					left="0"
					top="0"
					itemClick="onMapMenuItemSelect(event)"
					includeIn="dataview"
					itemSkin="com.ikanow.infinit.e.skins.ActivatorSkin">
					<fx:XMLList>
						<menuitem 
							label="Map Overlays..."
							color="0xFFFFFF">
							<menuitem id="_mapOverlay"
								label="Map"
								groupName="only"
								toggled="true"
								type="radio" />
							<menuitem id="_satOverlay"
								label="Satellite"
								groupName="only"
								type="radio" />
							<menuitem id="_terrainOverlay"
								label="Terrain"
								groupName="only"
								type="radio" />
							<menuitem id="_hybridOverlay"
								label="Hybrid"
								groupName="only"
								type="radio" />
						</menuitem>
					</fx:XMLList>
				</mx:MenuBar>

				<!-- ***************************************************
				INTEGRATION CODE : Add item to menu bar on the widget to
				show and hide the layers pane
				Need to update with accurate image location when integrated
				********************************************************-->

				<mx:Image id="toggleLayers"
					width="20"
					height="20"
					toolTip="Show the layers panel"
					click="showLayers()"
					alpha="0.5"
					buttonMode="true"
					mouseChildren="false"
					source="@Embed('/com/ikanow/infinit/e/assets/icons/kml256.png')"
					useHandCursor="true" />

				<!-- END OVERLAY CODE -->

				<s:Button id="_heatMapOverlayToggle"
					toolTip="Hide heat map overlay"
					click="onClickToggleHeatMap()"
					skinClass="com.ikanow.infinit.e.skins.MapHeatMapEnable" />

				<mx:Spacer width="10" />
				<s:Button id="_zoomModeToggle"
					toolTip="Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)"
					click="onClickZoomToggle(event)"
					skinClass="com.ikanow.infinit.e.skins.ZoomModeToggleSkin" />
				<s:Button id="_selectRegionToggle"
					toolTip="Enter region selection mode"
					click="onClickToggleRegionSelection()"
					skinClass="com.ikanow.infinit.e.skins.MapSelectRegionSkin" />
				<mx:Spacer width="10" />
				<s:Button id="_docGeoToggle"
					toolTip="Hide geo-tagged documents"
					click="onChangeMarkerSelection_docGeo(event)"
					skinClass="com.ikanow.infinit.e.skins.MapToggleDocSkin" />
				<s:Button id="_entityToggle"
					toolTip="Hide geo-tagged entities"
					click="onChangeMarkerSelection_entity(event)"
					skinClass="com.ikanow.infinit.e.skins.MapToggleEntitySkin" />
				<s:Button id="_eventToggle"
					toolTip="Hide geo-tagged events"
					click="onChangeMarkerSelection_event(event)"
					skinClass="com.ikanow.infinit.e.skins.MapToggleEventSkin" />
				<mx:LinkButton id="_ontologyToggle"
					toolTip="Select ontology types to show"
					label="Display Types"
					color="0xFFFFFF"
					click="onClickOntologyToggle(event)" />
			</s:HGroup>
		</mx:ApplicationControlBar>
		<mx:Spacer height="5" />
		<!-- Map -->

		<s:HGroup 
			width="100%"
			height="100%"
			includeIn="dataview">
			<s:Group id="_mapgroup"
				width="100%"
				height="100%"
				x="0"
				y="0"
				includeIn="dataview">

				<!-- Heatmap -->
				<ilog:DensityHeatMap id="_heatMapMiddelay"
					width="100%"
					height="100%"
					dataProvider="{ _heatMapData }"
					alpha="0.75"
					depth="1"
					mouseEnabled="false"
					pointSize="30"
					pointValue="10">
					<ilog:colorModel>
						<ilog:ColorModel>
							<ilog:ColorEntry 
								color="0x0000ff"
								alpha="0"
								limit="0" />
							<ilog:ColorEntry 
								color="0x00ff00"
								limit="50" />
							<ilog:ColorEntry 
								color="0xff0000"
								alpha="1"
								limit="100" />
						</ilog:ColorModel>
					</ilog:colorModel>
				</ilog:DensityHeatMap>

				<!-- Map -->
				<maps:Map id="_map"
					xmlns:maps="com.google.maps.*"
					width="100%"
					height="100%"
					x="0"
					y="0"
					key="{ API_KEY }"
					mapevent_mapready="onMapReady(event)" />


				<!-- Demo KML layers -->
				<components:DemoKmlLayers id="demoKmlLayers" />


			</s:Group>
		</s:HGroup>

	</s:VGroup>

	<s:VGroup 
		width="100%"
		height="100%"
		horizontalAlign="center"
		verticalAlign="middle"
		includeIn="nodata">
		<s:Label 
			text="No data, try running a query"
			includeIn="nodata" />
	</s:VGroup>

	<!-- Other -->

	<!-- 2] Other flex declarations etc -->

	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
		<fx:XML id="ontologyData">
			<root>
				<menuitem 
					label="Point"
					toggled="true"
					type="check" />
				<menuitem 
					label="City"
					toggled="true"
					type="check" />
				<menuitem 
					label="CountrySubsidiary"
					toggled="false"
					type="check" />
				<menuitem 
					label="Country"
					toggled="false"
					type="check" />
				<menuitem 
					label="GeographicalRegion"
					toggled="false"
					type="check" />
				<menuitem 
					label="Continent"
					toggled="false"
					type="check" />
			</root>
		</fx:XML>
	</fx:Declarations>

	<mx:states>
		<s:State name="dataview" />
		<s:State name="nodata" />
		<s:State name="dataviewinfo" />
	</mx:states>

	<fx:Style source="/com/ikanow/infinit/e/assets/styles/infiniteStyles.css">
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		/* If you need to override a style in our stylesheet, or add another
		style that we did not support you can do so here, an example has been commented out
		Please see documentation about over-riding MX component styles to display fonts*/
		/*
		mx|Text
		{
		font-family: infiniteNonCFFFont;
		}
		*/
	</fx:Style>

	<!-- 3] Inline script -->

	<fx:Script>
		<![CDATA[
			import com.google.maps.*;
			import com.google.maps.controls.*;
			import com.google.maps.overlays.*;
			import com.google.maps.styles.*;
			import com.ikanow.infinit.e.actionscript.GoogleMapKMLLoader;
			import com.ikanow.infinit.e.actionscript.InfiniteClusterIcons;
			import com.ikanow.infinit.e.actionscript.InfiniteMapPresentationLayer;
			import com.ikanow.infinit.e.skins.InfiniteFilterApplyOrIgnore;
			import com.ikanow.infinit.e.skins.MapGeoDecayEnable;
			import com.ikanow.infinit.e.skins.MapHeatMapEnable;
			import com.ikanow.infinit.e.skins.MapSelectRegionSkin;
			import com.ikanow.infinit.e.skins.MapToggleDocSkin;
			import com.ikanow.infinit.e.skins.MapToggleEntitySkin;
			import com.ikanow.infinit.e.skins.MapToggleEventSkin;
			import com.ikanow.infinit.e.skins.ZoomModeToggleSkin;
			import mx.collections.ArrayCollection;
			import mx.collections.XMLListCollection;
			import mx.controls.Alert;
			import mx.controls.LinkButton;
			import mx.controls.Menu;
			import mx.events.FlexMouseEvent;
			import mx.events.ItemClickEvent;
			import mx.events.MenuEvent;
			import mx.graphics.SolidColorStroke;
			import mx.managers.PopUpManager;
			import spark.components.BorderContainer;
			import spark.components.Panel;
			import spark.effects.Fade;
			import spark.primitives.Line;
			import flexlib.mdi.containers.MDIWindow;
			import org.alivepdf.colors.RGBColor;
			import org.alivepdf.data.Grid;
			import org.alivepdf.data.GridColumn;
			import org.alivepdf.display.Display;
			import org.alivepdf.fonts.FontFamily;
			import org.alivepdf.fonts.Style;
			import org.alivepdf.images.ImageFormat;
			import org.alivepdf.images.PNGImage;
			import org.alivepdf.images.ResizeMode;
			import org.alivepdf.layout.Align;
			import org.alivepdf.layout.Layout;
			import org.alivepdf.layout.Orientation;
			import org.alivepdf.layout.Size;
			import org.alivepdf.layout.Unit;
			import org.alivepdf.pages.Page;
			import org.alivepdf.pdf.PDF;
			import org.alivepdf.saving.Method;
			import system.data.sets.HashSet;
			
			// 3.1.2] Constants
			
			private const API_KEY:String = flash.external.ExternalInterface.call( "getMapLicenseKey" );
			
			// 3.1.3] Bindable parameters / other GUI-specific objects
			
			//(some horrible visualization hackery)			
			private var _mapResizeTimer:Timer = null;
			
			// Heatmap backing data:
			[Bindable]
			private var _heatMapData:XMLListCollection = new XMLListCollection();
			
			// Demo region select state:
			private var _regionSelectMarker:Marker = null;
			
			private var _regionStartLatLng:LatLng = null;
			
			private var _regionEndLatLng:LatLng = null;
			
			private var _regionRadiusSelect:Boolean = false;
			
			private var _regionRadiusDrag:Boolean = false;
			
			private var _regionSelectRadius:Polygon = null;
			
			private var _regionPopUp:BorderContainer = null;
			
			private var _regionOptionPopUp:BorderContainer = null;
			
			private var _regionTimer:Timer;
			
			private var _mouseStart:Point = null;
			
			private var _mouseEnd:Point = null;
			
			//hide markers
			private var _mapMarkerBounds:LatLngBounds = null;
			
			private var _needRecenter:Boolean = false;
			
			//loading last setup
			private var widgetOptions:Object = null;
			
			private var hasFilter:Boolean = false;
			
			private var internalFilterUpdate:Boolean = false;
			
			// 3.1.4] Presentation Layer object
			
			private var _presentationLayer:InfiniteMapPresentationLayer =
				new InfiniteMapPresentationLayer( this as InfiniteMapWidget, this as InfiniteMapWidget );
			
			// setHeatMapAvailable_fromPresentation - Allows the presentation layer to tell the GUI if a heat map can be displayed
			//
			// @param available: whether heat map data is available
			
			// (Some unpleasant state logic to handle the (framework failure?) case where this is set before 
			//  the map is ready...)
			private var _nSavedHeatMapState:int = -1;
			
			private var _kmlData:String = null;
			
			private var _kmlLoader:GoogleMapKMLLoader = null;
			
			private var layersOn:Boolean = false;
			
			private var _layerUrl:Object = null;
			
			private var _ontologyMenu:Menu = null;
			
			// isHeatMapEnabled_fromPresentation - So as to avoid wasiting time in presentation if it's not getting displayed...
			
			public function isHeatMapEnabled_fromPresentation():Boolean
			{
				if ( _nSavedHeatMapState >= 0 )
				{
					_heatMapOverlayToggle.enabled = ( 1 == _nSavedHeatMapState );
					var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
					_heatMapMiddelay.visible = btnskin.isSelected() && ( 1 == _nSavedHeatMapState );
					_nSavedHeatMapState = -1;
				}
				btnskin = _heatMapOverlayToggle.skin as MapHeatMapEnable;
				return ( _heatMapMiddelay.visible && btnskin.isSelected() && _heatMapOverlayToggle.enabled );
			}
			
			// Handle Radio Button List of Layers Events and Laod up new Geo Layers
			public function layerSelected( event:ItemClickEvent ):void
			{
				//load the new layer
				_layerUrl = demoKmlLayers.layers.selectedValue;
				loadUrl( _layerUrl.toString() );
			}
			
			// Event to load the Kml into the parser
			public function loadKml( event:Event ):void
			{
				_kmlLoader = new GoogleMapKMLLoader( _map, "Google Map Layer" );
				_kmlLoader.showPolygonEdges = true;
				_kmlLoader.opacity = 0.5;  //50% opacity no need for this
				_kmlData = event.target.data;
				
				// Need to re-render markers first (clears other overlays) then this KML:
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
			}
			
			// Load Url of KML file and fire event upon complete to kml parser
			public function loadUrl( url:String ):void
			{
				try
				{
					var loader:URLLoader = new URLLoader();
					loader.addEventListener( Event.COMPLETE, loadKml );
					loader.load( new URLRequest( url ) );
				}
				catch ( e:Error )
				{
					Alert.show( "Error loading layer, check the hostname and URL: " + url );
				}
			}
			
			// Which markers to display
			
			public function onChangeMarkerSelection_docGeo( event:MouseEvent ):void
			{
				var btnskin:MapToggleDocSkin = _docGeoToggle.skin as MapToggleDocSkin;
				
				if ( btnskin.isSelected() )
				{
					btnskin.changeSelected( false );
					_docGeoToggle.toolTip = "Show geo-tagged documents";
				}
				else
				{
					btnskin.changeSelected( true );
					_docGeoToggle.toolTip = "Hide geo-tagged documents";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
			public function onChangeMarkerSelection_entity( event:MouseEvent ):void
			{
				var btnskin:MapToggleEntitySkin = _entityToggle.skin as MapToggleEntitySkin;
				
				if ( btnskin.isSelected() )
				{
					btnskin.changeSelected( false );
					_entityToggle.toolTip = "Show geo-tagged entities";
				}
				else
				{
					btnskin.changeSelected( true );
					_entityToggle.toolTip = "Hide geo-tagged entities";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
			public function onChangeMarkerSelection_event( event:MouseEvent ):void
			{
				var btnskin:MapToggleEventSkin = _eventToggle.skin as MapToggleEventSkin;
				
				if ( btnskin.isSelected() )
				{
					btnskin.changeSelected( false );
					_eventToggle.toolTip = "Show geo-tagged events";
				}
				else
				{
					btnskin.changeSelected( true );
					_eventToggle.toolTip = "Hide geo-tagged events";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
			public function onClickOntologyToggle( event:MouseEvent ):void
			{
				if ( _ontologyMenu == null )
				{
					_ontologyMenu = Menu.createMenu( _ontologyToggle, _presentationLayer.getAllowedOntologyTypes(), true );
					_ontologyMenu.labelField = "label";
					_ontologyMenu.addEventListener( MenuEvent.CHANGE, ontologyMenuChangeEvent );
				}
				var ontPoint:Point = parent.localToGlobal( new Point( _ontologyToggle.x, _ontologyToggle.y ) );
				_ontologyMenu.show( ontPoint.x + 10, ontPoint.y + 30 );
			}
			
			/**
			 * Allow users to export the widget contents in the specified format
			 * @format filename: the filename+path to which the data will be written (in case it needs to be embedded)
			 * @param format: the format from the "supportedFormats" call
			 *
			 * @returns a ByteArray containing the data to output
			 */
			public function onGenerateExportData( filename:String, format:String ):ByteArray
			{
				var ba:ByteArray = new ByteArray();
				
				switch ( format.toLowerCase() )
				{
					case "kml":
						ba = createKML();
						break;
					default:
						break;
				}
				
				
				return ba;
			}
			/**
			 * function to build a pdf version of the widget
			 *
			 * @return pdf version of the widget
			 */
			public function onGeneratePDF( printPDF:PDF, title:String ):PDF
			{
				var MAX_IMAGE_WIDTH:int = 260;
				var MAX_IMAGE_HEIGHT:int = 190;
				printPDF.addPage( new Page( Orientation.LANDSCAPE, Unit.MM, Size.LETTER ) );
				printPDF.setFont( FontFamily.ARIAL, Style.UNDERLINE, 14 );
				printPDF.writeText( 14, title );
				printPDF.setFont( FontFamily.ARIAL, Style.NORMAL, 12 );
				printPDF.newLine( 10 );
				
				var bitmap:Bitmap = _map.getPrintableBitmap();
				var imageWidth:Number = bitmap.width;
				var imageHeight:Number = bitmap.height;
				
				if ( imageWidth >= imageHeight )
				{
					imageHeight = ( ( imageHeight / imageWidth ) * MAX_IMAGE_WIDTH );
					imageWidth = MAX_IMAGE_WIDTH;
				}
				else
				{
					imageWidth = ( ( imageWidth / imageHeight ) * MAX_IMAGE_HEIGHT );
					imageHeight = MAX_IMAGE_HEIGHT;
				}
				
				
				printPDF.addImage( bitmap, printPDF.getX(), printPDF.getY(), imageWidth, imageHeight, ImageFormat.PNG, 100, 1, ResizeMode.NONE );
				return printPDF;
			}
			
			/**
			 * If a save string has been saved from 'getSaveString' then
			 * when the app gets reloaded the last save string
			 * will be passed to this function.
			 *
			 * @param saveString the last save string or null if there was none
			 */
			public function onLoadWidgetOptions( widgetOptions:Object ):void
			{
				this.widgetOptions = widgetOptions;
			}
			
			/**
			 * function to rescale the module when the parent container is being resized
			 *
			 * @param newHeight The new height the component needs to be set to
			 * @param newWidth The new width the component needs to be set to
			 */
			public function onParentResize( newHeight:Number, newWidth:Number ):void
			{
				this.height = newHeight;
				this.width = newWidth;
				
				if ( null != _mapResizeTimer )
				{ // ie need map to be ready
					var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
					
					if ( btnskin.isSelected() && _heatMapOverlayToggle.enabled )
					{
						// Turn heat map off - it's too slow to redraw
						_heatMapMiddelay.visible = false;
						
						// Start a timer for 100ms time
						this._mapResizeTimer.stop();
						this._mapResizeTimer.start();
					}
				}
			}
			
			/**
			 * This function gets called when the workspace is being saved.
			 * return null if no save string is needed.
			 *
			 * @return a string this widget can use to reload state
			 */
			public function onSaveWidgetOptions():Object
			{
				if ( _map.initialized && _map.isLoaded() )
				{
					widgetOptions = new Object();
					widgetOptions[ "centerLat" ] = _map.getCenter().lat();
					widgetOptions[ "centerLng" ] = _map.getCenter().lng();
					widgetOptions[ "zoomLevel" ] = _map.getZoom();
					return widgetOptions;
				}
				return null;
			}
			
			public function recenterAndZoomMap_fromPresentation( minLat:Number, minLng:Number, maxLat:Number, maxLng:Number, override:Boolean = false ):void
			{
				if ( null == _mapResizeTimer )
				{ // Always auto-zoom if just opened, unless loading last setup
					_mapMarkerBounds = new LatLngBounds( new LatLng( minLat, minLng ), new LatLng( maxLat, maxLng ) );
					_needRecenter = true;
				}
				else
				{
					var btnskin:ZoomModeToggleSkin = this._zoomModeToggle.skin as ZoomModeToggleSkin;
					
					if ( override || btnskin.isSelected() )
					{
						_mapMarkerBounds = new LatLngBounds( new LatLng( minLat, minLng ), new LatLng( maxLat, maxLng ) );
						_needRecenter = true;
					}
				}
			}
			
			// renderHeatMapOverlay_fromPresentation - displays the heatmap if available
			//
			// @param geoArray: an XML list of x,y (pixels) 
			
			public function renderHeatMapOverlay_fromPresentation( geoArray:XMLList ):void
			{
				if ( null == geoArray )
				{
					_heatMapData.removeAll();
					_heatMapMiddelay.visible = false;
				}
				else
				{
					_heatMapData.source = geoArray;
						//(Can't have got here unless heat map visible)
				}
			}
			
			// 3.1.6] Visualization interface
			
			// SUMMARY:
			// renderMapOverlay_fromPresentation(clusteredMarkers, selectedGeolocations):void
			// renderHeatMapOverlay_fromPresentation(geoArray):void
			// setHeatMapAvailable_fromPresentation(available):void
			// isHeatMapEnabled_fromPresentation:Boolean
			
			// renderMapOverlay - displays the clusters generated by the presentation layer
			//
			// @param clusteredMarkers: 
			// @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			
			public function renderMapOverlay_fromPresentation( clusteredMarkers:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				//clear previous markers from map when new data is loaded.
				//after making sure it has been initialized
				if ( _map.initialized && _map.isLoaded() )
				{
					clusterMarkers( clusteredMarkers, selectedGeolocations );
					
					if ( _needRecenter )
						recenterMap();
				}
			}
			
			public function setHeatMapAvailable_fromPresentation( available:Boolean ):void
			{
				if ( null != _mapResizeTimer )
				{ // (this is one of the last things called when the map is ready)
					_heatMapOverlayToggle.enabled = available;
					var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
					_heatMapMiddelay.visible = btnskin.isSelected() && available;
				}
				else
				{
					_nSavedHeatMapState = int( available );
				}
			}
			
			// Function to show and hide the layers panel
			// Need to turn into a skin at some point
			public function showLayers():void
			{
				if ( layersOn )
				{
					layersOn = false;
					demoKmlLayers.visible = false;
					toggleLayers.toolTip = "Show the layers panel";
					toggleLayers.alpha = 0.5;
					_kmlData = null;
					_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
				}
				else
				{
					layersOn = true;
					demoKmlLayers.visible = true;
					toggleLayers.toolTip = "Hide the layers panel";
					toggleLayers.alpha = 1;
					
					if ( null != _layerUrl )
					{
						loadUrl( _layerUrl.toString() );
					}
				}
			}
			
			
			/**
			 * @returns A list of supported formats, displayed in a context menu in the format
			 * "Export <string>" - these are called with "generateExportData"
			 * Note this doesn't cover the "built-in" Alive PDF export.
			 * However if the developer specifies PDF and generatePdf() returns non-null then this will be used.
			 */
			
			public function supportedExportFormats():ArrayCollection
			{
				var ac:ArrayCollection = new ArrayCollection();
				ac.addItem( "pdf" );
				ac.addItem( "kml" );
				return ac;
			}
			
			protected function ontologyMenuChangeEvent( event:MenuEvent ):void
			{
				//have to redraw data with points changed					
				_presentationLayer.doMapDisplayProcessing();
			}
			
			// Timer to make help disappear
			
			private function _regionTimerTick( event:TimerEvent ):void
			{
				_regionTimer.stop();
				PopUpManager.removePopUp( _regionPopUp );
			}
			
			private function addAllMarkers( markerList:ArrayCollection, maxSize:Number ):void
			{
				for each ( var marker:Object in markerList )
				{
					addMarkers( marker[ "lat" ], marker[ "lon" ], marker[ "size" ], marker[ "alpha" ], marker[ "tooltip" ], marker[ "evtsize" ], maxSize );
				}
				
				// USER OVERLAYS:
				if ( ( null != _kmlData ) && ( null != _kmlLoader ) )
				{
					_kmlLoader.loadKML( _kmlData ); // now render the actual local overlays...
				}
			}
			
			/**
			 * function to add markers to the map based on lat and lon points
			 *
			 * @param lat The latitude of the point
			 * @param lon The longitude of the point
			 * @param markerSize The number of markers at the cluster
			 */
			private function addMarkers( lat:Number, lon:Number, markerSize:Number, alpha:Number, tooltip:String, eventSize:Number = 0, maxSize:Number = 1 ):void
			{
				var markers:Marker;
				
				var opts:MarkerOptions = new MarkerOptions();
				opts.iconAlignment = MarkerOptions.ALIGN_HORIZONTAL_CENTER + MarkerOptions.ALIGN_VERTICAL_CENTER;
				opts.strokeStyle = new StrokeStyle( { color: 0x987654 } );
				opts.fillStyle = new FillStyle( { color: 0x223344, alpha: 0.8 } );
				opts.radius = 12 + markerSize;
				opts.hasShadow = true;
				opts.icon = new InfiniteClusterIcons( markerSize.toString(), eventSize, maxSize );
				opts.icon.alpha = alpha;
				
				var btnskin2:MapSelectRegionSkin = _selectRegionToggle.skin as MapSelectRegionSkin;
				opts.clickable = !btnskin2.isSelected();
				
				if ( btnskin2.isSelected() )
				{
					opts.tooltip = tooltip + "\n[Mouse: no action, drag to select region as normal]";
				}
				else
				{
					var btnskin:ZoomModeToggleSkin = _zoomModeToggle.skin as ZoomModeToggleSkin;
					
					if ( btnskin.isSelected() )
					{
						opts.tooltip = tooltip + "\n[Mouse: zoom to cluster]";
					}
					else
					{
						opts.tooltip = tooltip + "\n[Mouse: add docs containing selected entities to filter]";
					}
				}
				
				var textForm:TextFormat = new TextFormat();
				textForm.bold = true;
				textForm.color = 0xFFFFFF;
				opts.labelFormat = textForm;
				
				markers = new Marker( new LatLng( lat, lon ), opts );
				markers.addEventListener( MapMouseEvent.CLICK, onMarkerClick );
				
				// In region select mode, want to treat a marker click exactly like a normal click
				if ( btnskin2.isSelected() )
				{
					markers.addEventListener( MapMouseEvent.MOUSE_MOVE, onMapMoveMouse );
					markers.addEventListener( MapMouseEvent.MOUSE_DOWN, onMouseDragStart );
					markers.addEventListener( MapMouseEvent.MOUSE_UP, onMouseDragEnd );
				}
				
				_map.addOverlay( markers );
			}
			
			private function addRegionToGeoDecay( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng ) / 1000; //convert to kilo by /1000
				_presentationLayer.onUpdateQuery_fromGUI( _regionStartLatLng, distance, false );
				optionPopUpLoseFocus( null );
			}
			
			// Region select options:
			
			private function addRegionToQuery( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng ) / 1000; //convert to kilo by /1000
				this.addRegionToQuery_fromPresentation( _regionStartLatLng, distance );
				optionPopUpLoseFocus( null );
			}
			
			private function cancelRegionSelection( event:Event ):void
			{
				optionPopUpLoseFocus( null );
			}
			
			// 3.1.7] Visualization utilities			
			
			/**
			 * function to get clusters to add markers to the map
			 *
			 * @param clusters The array collection of clusters to add to the map
			 * @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			 */
			private function clusterMarkers( clusters:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				_map.clearOverlays();
				var tempMarkerList:ArrayCollection = new ArrayCollection();
				var maxDocCount:Number = 1;
				
				// Display settings:
				var docbtnskin:MapToggleDocSkin = _docGeoToggle.skin as MapToggleDocSkin;
				var entbtnskin:MapToggleEntitySkin = _entityToggle.skin as MapToggleEntitySkin;
				var evtbtnskin:MapToggleEventSkin = _eventToggle.skin as MapToggleEventSkin;
				
				for each ( var group:ArrayCollection in clusters )
				{
					var alpha:Number = ( null == selectedGeolocations ) ? 1.0 : 0.5;
					var feedidSet:HashSet = new HashSet();
					var eventCount:Number = 0;
					var entityCount:Number = 0;
					var docGeoCount:Number = 0;
					
					for each ( var geo:Object in group )
					{
						if ( geo.object_type == "entity" )
						{
							if ( !entbtnskin.isSelected() )
								continue;
							entityCount++;
						}
						else if ( geo.object_type == "docgeo" )
						{
							if ( !docbtnskin.isSelected() )
								continue;
							docGeoCount++;
						}
						else
						{
							if ( !evtbtnskin.isSelected() )
								continue;
							eventCount++;
						}
						feedidSet.add( geo.feed );
						
						if ( ( null != selectedGeolocations ) && selectedGeolocations.contains( geo.index ) )
						{
							alpha = 1.0;
						}
					}
					
					if ( 0 == ( entityCount + docGeoCount + eventCount ) )
					{
						continue; // (only display markers containing something)
					}
					var tempMarker:Object = new Object();
					tempMarker[ "lat" ] = group[ 0 ].geotag.lat;
					tempMarker[ "lon" ] = group[ 0 ].geotag.lon;
					tempMarker[ "size" ] = feedidSet.size();
					tempMarker[ "alpha" ] = alpha;
					tempMarker[ "tooltip" ] = "Documents: " + feedidSet.size() + "\nDocument Geotags: " + docGeoCount + "\nGeotags: " + entityCount + "\nEvents: " + eventCount;
					tempMarker[ "evtsize" ] = eventCount;
					tempMarkerList.addItem( tempMarker );
					
					if ( feedidSet.size() > maxDocCount )
						maxDocCount = feedidSet.size();
				}
				addAllMarkers( tempMarkerList, maxDocCount );
			}
			
			private function createKML():ByteArray
			{
				
				var docbtnskin:MapToggleDocSkin = _docGeoToggle.skin as MapToggleDocSkin;
				var entbtnskin:MapToggleEntitySkin = _entityToggle.skin as MapToggleEntitySkin;
				var evtbtnskin:MapToggleEventSkin = _eventToggle.skin as MapToggleEventSkin;
				
				var xml:String = "<kml xmlns=\"http://www.opengis.net/kml/2.2\"><Document>";
				xml += "<Style id=\"Document\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/wht-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Entity\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Event\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ltblu-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"DocEnt\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href></Icon></IconStyle></Style>";
				
				//var level:int = 20 - _map.getZoom();
				//var range:int = Math.round(Math.pow(2 ,level) * Math.sqrt((_map.width * _map.width) + (_map.height * _map.height)) / 3.3);
				var snip:Number = 26 - _map.getZoom() * Math.log( 2 );
				var range:int = Math.round( Math.pow( 2, snip ) );
				//				var zoom:int = zoom = Math.round(26-(Math.log(range)/Math.log(2)));
				xml += "<LookAt><longitude>" + _map.getCenter().lng() + "</longitude><latitude>" + _map.getCenter().lat() + "</latitude><range>" + range + "</range><tilt>0</tilt></LookAt>";
				
				var feedData:ArrayCollection = _context.getQuery_TopResults().getTopDocuments();
				
				var entityKml:String = "";
				var eventKml:String = "";
				var docKml:String = "";
				var docEntKml:String = "";
				
				for each ( var feed:Object in feedData )
				{
					//loop through the feed to get its entities
					
					for each ( var entity:Object in feed.entities )
					{
						//check to make sure the entity has geotags 
						if ( entity.geotag != null )
						{
							var commonString:String = "<p><b>Entity Type:</b> " + entity.type + "</p>";
							commonString += "<p><b>Document Significance:</b> " + Math.round( Number( entity.significance ) ) + "%</p>";
							commonString += "<p><b>Query Significance:</b> " + Math.round( Number( entity.datasetSignificance ) ) + "%</p>";
							commonString += "<p><b>Relevance:</b> " + ( Math.round( Number( entity.relevance ) * 100 ) ).toPrecision( 2 ) + "%</p>";
							commonString += "<p><b>Frequency:</b> " + entity.frequency + "</p>";
							
							if ( feed.url.substr( 0, 5 ) == "http:" )
							{
								commonString += "<p><b>Url: <b/>" + feed.url + "</p>";
							}
							
							var entVis:String = "";
							
							if ( !entbtnskin.isSelected() )
							{
								entVis += "<visibility>0</visibility>";
							}
							
							
							var entDesc:String = "<![CDATA[";
							entDesc += "<p><b>Feed: " + feed.title + "</b></p>";
							entDesc += commonString;
							entDesc += "\]\]>";
							
							var docEntDesc:String = "<![CDATA[";
							docEntDesc += "<p><b>Entity:</b> " + entity.disambiguated_name + "</p>";
							docEntDesc += commonString;
							docEntDesc += "\]\]>";
							
							
							entityKml += "<Placemark>" + entVis + "<name>Entity: " + entity.disambiguated_name + "</name><description>" + entDesc + "</description><styleUrl>#Entity</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							docEntKml += "<Placemark>" + entVis + "<name>" + feed.title + "</name><description>" + docEntDesc + "</description><styleUrl>#DocEnt</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
						}
					}
					
					//loop through the feed to get its events
					for each ( var event:Object in feed.associations )
					{
						//check to make sure the event has geotags
						if ( event.geotag != null )
						{
							
							var eventDesc:String = "<![CDATA[";
							
							eventDesc += "<p><b>Feed: </b>" + feed.title + "</p>";
							
							if ( event.entity1 != null )
							{
								eventDesc += "<p><b>Entity 1:</b> " + event.entity1 + "</p>";
							}
							
							if ( event.verb != null )
							{
								eventDesc += "<p><b>Verb:</b> " + event.verb + "</p>";
							}
							
							if ( event.entity2 != null )
							{
								eventDesc += "<p><b>Entity 2:</b> " + event.entity2 + "</p>";
							}
							
							var time:String = "";
							
							if ( event.geotag.time_start != null )
							{
								eventDesc += "<p><b>Time Start:</b>" + event.geotag.time_start + "</p>";
								time += "<TimeStamp>" + event.geotag.time_start + "</TimeStamp>";
							}
							
							eventDesc += "\]\]>";
							
							var evtVis:String = "";
							
							if ( !evtbtnskin.isSelected() )
							{
								evtVis += "<visibility>0</visibility>";
							}
							
							eventKml += "<Placemark>" + evtVis + "<name>Event: " + event.verb_category + "</name>" + time + "<description>" + eventDesc + "</description><styleUrl>#Event</styleUrl>" + "<Point><coordinates>" + event.geotag.lon + "," + event.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							
						}
					}
					
					//get a documents docgeo if it exists
					if ( feed.docGeo != null )
					{
						var docDesc:String = "<![CDATA[";
						
						docDesc += "<p><b>Description: </b>" + feed.description + "</p>";
						
						if ( feed.url.substr( 0, 5 ) == "http:" )
						{
							docDesc += "<p><b>Url: </b>" + feed.url + "</p>";
						}
						
						docDesc += "\]\]>";
						
						var docVis:String = "";
						
						if ( !docbtnskin.isSelected() )
						{
							docVis += "<visibility>0</visibility>";
						}
						
						docKml += "<Placemark>" + docVis + "<name>" + feed.title + "</name><description>" + docDesc + "</description><styleUrl>#Document</styleUrl>" + "<Point><coordinates>" + feed.docGeo.lon + "," + feed.docGeo.lat + ",0" + "</coordinates></Point></Placemark>";
					}
				}
				
				
				
				xml += "<Folder><name>Geo-tagged Entities</name>";
				
				if ( !entbtnskin.isSelected() )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += entityKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Documents</name>";
				
				if ( !docbtnskin.isSelected() )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += docKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Events</name>";
				
				if ( !evtbtnskin.isSelected() )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += eventKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Documents Containing Geo-tagged Entities</name>";
				xml += docEntKml;
				xml += "</Folder>";
				
				xml += "</Document></kml>";
				
				var x:XML = new XML( xml );
				
				var ba:ByteArray = new ByteArray();
				ba.writeUTFBytes( x );
				return ba;
			
			}
			
			private function doneResizingMap( event:TimerEvent ):void
			{
				var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
				
				if ( btnskin.isSelected() && _heatMapOverlayToggle.enabled )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
					
					// For some reason call entire procesing after map finished moving, only heat map after resize?
					_presentationLayer.heatMapRedraw_fromGUI();
				}
			}
			
			/**
			 * Callback to handle the "ignore/allow" local filter button getting pressed
			 */
			private function onClickIgnoreLocalFilter():void
			{
				internalFilterUpdate = true;
				var parent:Object = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent as Object : this.parent.parent.parent as Object;
				var btnskin:InfiniteFilterApplyOrIgnore = _localFilterSettings.skin as InfiniteFilterApplyOrIgnore;
				
				if ( btnskin.isSelected() )
				{ // Now applying internal filtering
					if ( hasFilter )
						_presentationLayer.toggleFilter_fromGUI( true );
					else
						_presentationLayer.toggleFilter_fromGUI( false );
					
					btnskin.changeSelected( false );
					_localFilterSettings.toolTip = "Ignore Internal Filtering";
					var title:String = parent.title;
					parent.title = title.substring( 0, title.lastIndexOf( " (ignore internal filtering)" ) );
				}
				else
				{	// Now ignoring internal filtering
					
					_presentationLayer.toggleFilter_fromGUI( false );
					
					btnskin.changeSelected( true );
					_localFilterSettings.toolTip = "Apply Internal Filtering";
					parent.title = parent.title + " (ignore internal filtering)";
				}
				internalFilterUpdate = false;
			}
			
			/**
			 * Callback to handle turning the heatmap on or off...
			 */
			private function onClickToggleHeatMap():void
			{
				var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
				
				if ( btnskin.isSelected() )
				{ // Now disabling heat map
					btnskin.changeSelected( false );
					_heatMapOverlayToggle.toolTip = "Show heat map overlay (only if geo aggregation selected in the advanced query options)";
					_heatMapMiddelay.visible = false;
				}
				else
				{ // Heat map enabled
					btnskin.changeSelected( true );
					_heatMapOverlayToggle.toolTip = "Hide heat map overlay";
					_heatMapMiddelay.visible = true;
					_presentationLayer.heatMapRedraw_fromGUI();
				}
			}
			/**
			 * Callback to start/stop region selection mode
			 */
			private function onClickToggleRegionSelection():void
			{
				var btnskin:MapSelectRegionSkin = _selectRegionToggle.skin as MapSelectRegionSkin;
				
				if ( btnskin.isSelected() )
				{ // Leaving region selection mode
					
					_map.enableDragging();
					
					btnskin.changeSelected( false );
					_selectRegionToggle.toolTip = "Enter region selection mode";
					
					if ( _regionSelectMarker != null )
						_map.removeOverlay( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
						_map.removeOverlay( _regionSelectRadius );
					_regionSelectRadius = null;
					_regionSelectMarker = null;
					_regionRadiusSelect = false;
				}
				else
				{ // Entering region selection mode
					btnskin.changeSelected( true );
					_selectRegionToggle.toolTip = "Leave region selection mode (will lose any selected regions)";
					//display message prompting user to click/drag
					showRegionSelectPopUp();
					_regionRadiusSelect = true;
					
					_map.disableDragging();
				}
				// Redraw the clusters with clickability on/off
				_presentationLayer.doMapDisplayProcessing();
			}
			
			// Other callback code
			
			private function onClickZoomToggle( event:MouseEvent ):void
			{
				var btnskin:ZoomModeToggleSkin = _zoomModeToggle.skin as ZoomModeToggleSkin;
				
				if ( btnskin.isSelected() )
				{
					btnskin.changeSelected( false );
					_zoomModeToggle.toolTip = "Enter click-to-zoom mode/leave click-to-filter mode (and re-enable auto-zoom)";
				}
				else
				{
					btnskin.changeSelected( true );
					_zoomModeToggle.toolTip = "Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
			private function onMapFinishedMoving( event:Event ):void
			{
				var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
				
				if ( btnskin.isSelected() && _heatMapOverlayToggle.enabled )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
				}
				// For some reason call entire procesing after map finished moving, only heat map after resize?
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
				
				_regionSelectMarker = null; // (on zoom, remove the region select marker)
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * Note contained in this viz layer, since it's just a GUI function
			 *
			 * @param event The IndexChangeEvent received when a map type is selected on the tabbar
			 */
			private function onMapMenuItemSelect( event:MenuEvent ):void
			{
				if ( event.index == 0 )
				{
					_map.setMapType( MapType.NORMAL_MAP_TYPE );
				}
				
				if ( event.index == 1 )
				{
					_map.setMapType( MapType.SATELLITE_MAP_TYPE );
				}
				
				if ( event.index == 2 )
				{
					_map.setMapType( MapType.PHYSICAL_MAP_TYPE );
				}
				
				if ( event.index == 3 )
				{
					_map.setMapType( MapType.HYBRID_MAP_TYPE );
				}
			}
			
			private function onMapMoveMouse( event:MapMouseEvent ):void
			{
				if ( _regionRadiusDrag )
				{
					if ( _regionSelectRadius != null )
					{
						_map.removeOverlay( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					var polyOptions:PolygonOptions = new PolygonOptions();
					polyOptions.strokeStyle = new StrokeStyle( { color: 0xFF0000 } );
					polyOptions.fillStyle = new FillStyle( { color: 0xCCCCCC, alpha: 0.5 } );
					
					var polyArray:Array = new Array();
					
					// (need to save this here since onMouseDragEnd can be the wrong lat/long if generated from marker)
					_regionEndLatLng = new LatLng( event.latLng.lat(), event.latLng.lng(), true );
					
					//create an array of 40 points to create a circle around the
					//start point for region
					var distance:Number = _regionStartLatLng.distanceFrom( event.latLng );
					var circlePoints:Number = 40;
					var circleLat:Number = ( distance / 1000 ) * 0.621371192 * 0.014483;
					var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat() * ( Math.PI / 180 ) );
					
					for ( var i:int = 0; i < circlePoints; i++ )
					{
						var theta:Number = Math.PI * ( ( 2 * i ) / circlePoints );
						var pointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
						var pointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
						polyArray.push( new LatLng( pointLat, pointLng, true ) );
					}
					
					_regionSelectRadius = new Polygon( polyArray, polyOptions );
					_map.addOverlay( _regionSelectRadius );
				}
			}
			
			/**
			 * Callback to initialize the map variables when it's done loading
			 *
			 * @param event The Event received when the map is ready
			 */
			private function onMapReady( event:Event ):void
			{
				// Map specific code:
				this._map.key = API_KEY;
				this._map.setCenter( new LatLng( 20.676362, 5.992188 ), 3, MapType.NORMAL_MAP_TYPE );
				this._map.zoomOut( null, true );
				this._map.addControl( new ZoomControl() );
				this._map.addControl( new PositionControl );
				this._map.enableScrollWheelZoom();
				
				// Handle map movement
				this._map.addEventListener( MapMoveEvent.MOVE_START, onMapStartedMoving );
				this._map.addEventListener( MapMoveEvent.MOVE_END, onMapFinishedMoving );
				
				// Handle region selection
				this._map.addEventListener( MapMouseEvent.MOUSE_MOVE, onMapMoveMouse );
				this._map.addEventListener( MapMouseEvent.MOUSE_DOWN, onMouseDragStart );
				this._map.addEventListener( MapMouseEvent.MOUSE_UP, onMouseDragEnd );
				
				this._map.enabled = true;
				this._map.visible = true;
				
				// Timer for heatmap optimization
				_mapResizeTimer = new Timer( 100, 1 ); // (runs once after 100ms)
				_mapResizeTimer.addEventListener( TimerEvent.TIMER_COMPLETE, doneResizingMap );
				
				// KML layers
				
				this.demoKmlLayers.layers.addEventListener( ItemClickEvent.ITEM_CLICK, layerSelected );
				
				// Let the presentation layer know the bounds
				
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
			}
			/**
			 * Callback to handle the user stopping dragging the mouse (or zooming??)
			 */
			private function onMapStartedMoving( event:Event ):void
			{
				_heatMapMiddelay.visible = false;
				
				//clear any region selecting
				if ( _regionSelectMarker != null )
					_map.removeOverlay( _regionSelectMarker );
				
				if ( _regionSelectRadius != null )
					_map.removeOverlay( _regionSelectRadius );
				_regionSelectRadius = null;
				_regionSelectMarker = null;
				_regionRadiusSelect = false;
				// (cancel regions select mode if enabled)
				var btnskin:MapSelectRegionSkin = this._selectRegionToggle.skin as MapSelectRegionSkin;
				
				if ( btnskin.isSelected() )
				{ //first click set marker and await drag end
					optionPopUpLoseFocus( null );
				}
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * (currently: ignore unless it hits a marker)
			 */
			private function onMarkerClick( event:com.google.maps.MapMouseEvent ):void
			{
				// Not if in region selection code
				var btnskin:MapSelectRegionSkin = this._selectRegionToggle.skin as MapSelectRegionSkin;
				
				if ( !btnskin.isSelected() )
				{
					
					var btnskin2:ZoomModeToggleSkin = this._zoomModeToggle.skin as ZoomModeToggleSkin;
					
					if ( btnskin2.isSelected() )
					{
						_presentationLayer.onZoomToCluster_fromGUI( event.latLng.lat(), event.latLng.lng() );
					}
					else
					{
						_presentationLayer.onFilterClusterFromLatLong_fromGUI( event.latLng.lat(), event.latLng.lng() );
					}
				}
			}
			
			private function onMouseDragEnd( event:MapMouseEvent ):void
			{
				if ( _regionRadiusSelect ) //if we are done dragging out a region
				{
					_mouseEnd = new Point( _map.mouseX, _map.mouseY );
					
					if ( ( Math.abs( _mouseEnd.x - _mouseStart.x ) > 5 ) || ( Math.abs( _mouseEnd.y - _mouseStart.y ) > 5 ) )
					{
						//prompt user on what they want to do with region:
						_regionRadiusSelect = false;
						_regionRadiusDrag = false;
						showRegionOptionsPopUp();
					}
					else //was a click event, so restart marker drag
					{
						if ( null != _regionSelectMarker )
							_map.removeOverlay( _regionSelectMarker );
						_regionRadiusDrag = false;
						
						if ( _regionSelectRadius != null )
						{
							_map.removeOverlay( _regionSelectRadius );
							_regionSelectRadius = null;
						}
					}
				}
			}
			
			// Dragging in region select mode
			
			private function onMouseDragStart( event:MapMouseEvent ):void
			{
				if ( _regionRadiusSelect ) //first click set marker and await drag end
				{
					_mouseStart = new Point( _map.mouseX, _map.mouseY );
					_map.setFocus();
					
					if ( null != _regionSelectMarker )
						_map.removeOverlay( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
					{
						_map.removeOverlay( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					_regionSelectMarker = new Marker( event.latLng );
					_map.addOverlay( _regionSelectMarker );
					_regionStartLatLng = event.latLng;
					_regionRadiusDrag = true;
				}
			}
			
			// 3.1.5] Callbacks
			
			/**
			 * Method fired when module is done loading.  Sends
			 * message to parent letting it know that module is
			 * ready to receive data.
			 */
			private function onWidgetCreationComplete():void
			{
				// (These need to be set-up programmatically)
				var btnskin:MapHeatMapEnable = _heatMapOverlayToggle.skin as MapHeatMapEnable;
				btnskin.changeSelected( true, false );
				var btnskin2:ZoomModeToggleSkin = _zoomModeToggle.skin as ZoomModeToggleSkin;
				btnskin2.changeSelected( true, false );
				var docbtnskin:MapToggleDocSkin = _docGeoToggle.skin as MapToggleDocSkin;
				docbtnskin.changeSelected( true, false );
				var entbtnskin:MapToggleEntitySkin = _entityToggle.skin as MapToggleEntitySkin;
				entbtnskin.changeSelected( true, false );
				var evtbtnskin:MapToggleEventSkin = _eventToggle.skin as MapToggleEventSkin;
				evtbtnskin.changeSelected( true, false );
			}
			
			// Handles selecting an option
			
			private function optionPopUpLoseFocus( event:FlexMouseEvent ):void
			{
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				if ( _regionOptionPopUp != null )
				{
					_regionOptionPopUp.removeEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
					PopUpManager.removePopUp( _regionOptionPopUp );
				}
				
				if ( event == null || event.relatedObject != _selectRegionToggle )
				{
					onClickToggleRegionSelection();
					_map.enableDragging();
				}
			}
			
			private function recenterMap():void
			{
				if ( _map.initialized && _map.isLoaded() && _mapMarkerBounds != null )
				{
					_needRecenter = false;
					
					if ( widgetOptions != null )
					{
						_map.setCenter( new LatLng( widgetOptions.centerLat, widgetOptions.centerLng ), widgetOptions.zoomLevel, MapType.NORMAL_MAP_TYPE );
						widgetOptions = null;
					}
					else
					{
						var zoomLevel:Number = _map.getBoundsZoomLevel( _mapMarkerBounds )
						var centerPoint:LatLng = _mapMarkerBounds.getCenter();
						_map.setCenter( centerPoint, zoomLevel );
					}
				}
			}
			
			// (options)
			
			private function showRegionOptionsPopUp():void
			{
				//create it
				if ( _regionOptionPopUp == null )
				{
					var sepVGroup1:VGroup = new VGroup();
					sepVGroup1.horizontalAlign = "center";
					sepVGroup1.verticalAlign = "middle";
					sepVGroup1.percentHeight = 100;
					sepVGroup1.percentWidth = 100;
					var seperator1:Line = new Line();
					seperator1.percentWidth = 90;
					seperator1.yFrom = 1;
					seperator1.yTo = 1;
					seperator1.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup1.addElement( seperator1 );
					
					var sepVGroup2:VGroup = new VGroup();
					sepVGroup2.horizontalAlign = "center";
					sepVGroup2.verticalAlign = "middle";
					sepVGroup2.percentHeight = 100;
					sepVGroup2.percentWidth = 100;
					var seperator2:Line = new Line();
					seperator2.percentWidth = 90;
					seperator2.yFrom = 1;
					seperator2.yTo = 1;
					seperator2.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup2.addElement( seperator2 );
					
					var link1:LinkButton = new LinkButton();
					link1.label = "Add region to query";
					link1.addEventListener( "click", addRegionToQuery );
					
					var link2:LinkButton = new LinkButton();
					link2.label = "Set region as geo decay";
					link2.addEventListener( "click", addRegionToGeoDecay );
					
					var link3:LinkButton = new LinkButton();
					link3.label = "Zoom to region";
					link3.addEventListener( "click", zoomToRegion );
					
					var linkCancel:LinkButton = new LinkButton();
					linkCancel.label = "Cancel region selection";
					linkCancel.addEventListener( "click", cancelRegionSelection );
					
					var vg:VGroup = new VGroup();
					vg.verticalAlign = "middle";
					vg.horizontalAlign = "left";
					vg.percentHeight = 100;
					vg.percentWidth = 100;
					vg.addElement( link1 );
					vg.addElement( link2 );
					vg.addElement( sepVGroup1 );
					vg.addElement( link3 );
					vg.addElement( sepVGroup2 );
					vg.addElement( linkCancel );
					_regionOptionPopUp = new BorderContainer();
					_regionOptionPopUp.alpha = 1;
					_regionOptionPopUp.setStyle( "paddingBottom", 2 );
					_regionOptionPopUp.setStyle( "paddingTop", 2 );
					_regionOptionPopUp.setStyle( "paddingLeft", 2 );
					_regionOptionPopUp.setStyle( "paddingRight", 2 );
					_regionOptionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionOptionPopUp.setStyle( "cornerRadius", 5 );
					_regionOptionPopUp.percentWidth = 100;
					_regionOptionPopUp.percentHeight = 100;
					_regionOptionPopUp.addElement( vg );
				}
				//then show it
				var popupX:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.x : this.parent.parent.parent.x;
				var popupY:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.y : this.parent.parent.parent.y + 60;
				_regionOptionPopUp.x = popupX + _mouseEnd.x;
				_regionOptionPopUp.y = popupY + _mouseEnd.y;
				
				// (remove other popup)
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				// show this pop up
				PopUpManager.removePopUp( _regionOptionPopUp );
				PopUpManager.addPopUp( _regionOptionPopUp, this, false );
				PopUpManager.bringToFront( _regionOptionPopUp );
				
				_regionOptionPopUp.setFocus();
				_regionOptionPopUp.addEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
			}
			
			//
			// Lots of region selection logic:
			//
			
			// Pop ups
			
			// (help)
			
			private function showRegionSelectPopUp():void
			{
				//create the popup if needbe
				if ( _regionPopUp == null )
				{
					var label:Label = new Label();
					label.text = "Click a location and drag to select a region";
					var hg:HGroup = new HGroup();
					hg.verticalAlign = "middle";
					hg.horizontalAlign = "center";
					hg.percentHeight = 100;
					hg.percentWidth = 100;
					hg.addElement( label );
					_regionPopUp = new BorderContainer();
					_regionPopUp.alpha = 1;
					_regionPopUp.setStyle( "paddingBottom", 2 );
					_regionPopUp.setStyle( "paddingTop", 2 );
					_regionPopUp.setStyle( "paddingLeft", 2 );
					_regionPopUp.setStyle( "paddingRight", 2 );
					_regionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionPopUp.setStyle( "cornerRadius", 5 );
					_regionPopUp.width = 320;
					_regionPopUp.height = 40;
					_regionPopUp.addElement( hg );
					
					_regionTimer = new Timer( 4000 );
					_regionTimer.addEventListener( TimerEvent.TIMER, _regionTimerTick );
				}
				
				//then show it
				PopUpManager.removePopUp( _regionPopUp );
				PopUpManager.addPopUp( _regionPopUp, this, false );
				PopUpManager.centerPopUp( _regionPopUp );
				_regionTimer.stop();
				_regionTimer.start();
			}
			
			private function zoomToRegion( event:Event ):void
			{
				optionPopUpLoseFocus( null );
				
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng );
				var circleLat:Number = ( distance / 1000 ) * 0.621371192 * 0.014483;
				var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat() * ( Math.PI / 180 ) );
				var theta:Number = Math.PI / 4;
				//CALC NE Point (45 degrees i.e. pi/4
				
				var nepointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
				var nepointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
				
				//CALC SW Point (5pi/4)
				theta = 5 * Math.PI / 4;
				var swpointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
				var swpointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
				
				//create bounds from points and zoom to that
				var bounds:LatLngBounds = new LatLngBounds( new LatLng( swpointLat, swpointLng ), new LatLng( nepointLat, nepointLng ) );
				_map.setCenter( bounds.getCenter(), _map.getBoundsZoomLevel( bounds ) );
			
			}
			/** END OVERLAY CODE **/
		]]>
	</fx:Script>

	<!-- Ideally this should be a separate object to enforce encapsulation between the Model
	and Visualization layers. Will worry about how to do this if the experiment is otherwise
	a success-->

	<fx:Script source="com/ikanow/infinit/e/actionscript/InfiniteMapModelLayer.as" />
</mx:Module>
