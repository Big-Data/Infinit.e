<?xml version="1.0" encoding="utf-8"?>
<!--

The MIT License
Copyright (c) 2011 IKANOW llc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-->

<components:WidgetModule xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:actionscript="com.ikanow.infinit.e.actionscript.*"
	xmlns:components="com.ikanow.infinit.e.widget.library.components.*"
	xmlns:components1="com.ikanow.infinit.e.components.*"
	xmlns:framework="com.ikanow.infinit.e.widget.library.framework.*"
	xmlns:ilog="http://www.ilog.com/2007/ilog/flex"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	implements="com.ikanow.infinit.e.widget.library.widget.IWidget"
	creationComplete="{ try { onWidgetCreationComplete(); } catch (e:Error) {  }  dispatchEvent(new Event('Done Loading')); }">

	<!-- Header -->
	<components:headerContent>

		<s:HGroup gap="-3">

			<!-- Ignore Filter Toggle Button -->
			<components:WidgetIgnoreFilterToggleButton id="localFilterSettings"
				toolTip="Ignore Workspace Filtering - Show All Results"
				click="setTimeout( onClickIgnoreLocalFilter, 100 )" />

			<!-- Zoom Toggle Button -->
			<components:WidgetZoomToggleButton id="zoomToggleButton"
				toolTip="Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)"
				change="zoomToggleButton_changeHandler(event)" />

			<!-- Layers Toggle Button -->
			<components:WidgetLayersToggleButton id="layersToggleButton"
				toolTip="Show the layers panel"
				change="layersToggleButton_changeHandler(event)" />

			<!-- Region Select Toggle Button -->
			<components:WidgetRegionSelectToggleButton id="regionSelectToggleButton"
				toolTip="Enter region selection mode"
				change="regionSelectToggleButton_changeHandler(event)" />

			<!-- Map Overlays Drop Down List -->
			<components:WidgetPromptDropDownList id="overlayOptions"
				width="95"
				selectedIndex="{ MAP_OVERLAY }"
				change="setTimeout( overlayOptions_changeHandler, 100, event )"
				listWidth="93"
				prompt="Overlays">
				<components:dataProvider>
					<s:ArrayList source="[Map,Satellite,Terrain,Hybrid]" />
				</components:dataProvider>
			</components:WidgetPromptDropDownList>

			<!-- Show Options Drop Down List -->
			<components:WidgetPromptCheckBoxDropDownList id="showOptions"
				width="76"
				selectedIndex="-1"
				dataProvider="{ _presentationLayer.getShowOptions() }"
				change="setTimeout( showOptions_changeHandler, 100, event )"
				listWidth="190"
				prompt="Show" />

			<!-- Display Types Drop Down List -->
			<components:WidgetPromptCheckBoxDropDownList id="displayTypes"
				width="125"
				selectedIndex="-1"
				dataProvider="{ _presentationLayer.getAllowedOntologyTypes() }"
				change="setTimeout( displayTypes_changeHandler, 100, event )"
				listWidth="170"
				prompt="Display Types" />

		</s:HGroup>

	</components:headerContent>

	<!-- 1] GUI declaration -->

	<!-- Map -->

	<s:HGroup 
		width="100%"
		height="100%"
		includeIn="dataview">
		<s:Group id="_mapgroup"
			width="100%"
			height="100%"
			x="0"
			y="0"
			includeIn="dataview">

			<!-- Heatmap -->
			<ilog:DensityHeatMap id="_heatMapMiddelay"
				width="100%"
				height="100%"
				dataProvider="{ _heatMapData }"
				alpha="0.75"
				depth="1"
				mouseEnabled="false"
				pointSize="30"
				pointValue="10">
				<ilog:colorModel>
					<ilog:ColorModel>
						<ilog:ColorEntry 
							color="0x0000ff"
							alpha="0"
							limit="0" />
						<ilog:ColorEntry 
							color="0x00ff00"
							limit="50" />
						<ilog:ColorEntry 
							color="0xff0000"
							alpha="1"
							limit="100" />
					</ilog:ColorModel>
				</ilog:colorModel>
			</ilog:DensityHeatMap>

			<!-- Map -->
			<maps:Map id="_map"
				xmlns:maps="com.google.maps.*"
				width="100%"
				height="100%"
				x="0"
				y="0"
				key="{ API_KEY }"
				mapevent_mapready="onMapReady(event)" />


			<!-- Demo KML layers -->
			<components1:DemoKmlLayers id="demoKmlLayers" />

		</s:Group>

	</s:HGroup>

	<s:VGroup 
		width="100%"
		height="100%"
		horizontalAlign="center"
		verticalAlign="middle"
		includeIn="nodata">
		<s:Label 
			text="No data, try running a query"
			includeIn="nodata" />
	</s:VGroup>

	<!-- Other -->

	<!-- 2] Other flex declarations etc -->

	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>

	<components:states>
		<s:State name="dataview" />
		<s:State name="nodata" />
		<s:State name="dataviewinfo" />
	</components:states>

	<fx:Style source="/com/ikanow/infinit/e/assets/styles/infiniteStyles.css">
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		/* If you need to override a style in our stylesheet, or add another
		style that we did not support you can do so here, an example has been commented out
		Please see documentation about over-riding MX component styles to display fonts*/
		/*
		mx|Text
		{
		font-family: infiniteNonCFFFont;
		}
		*/
	</fx:Style>

	<!-- 3] Inline script -->

	<fx:Script>
		<![CDATA[
			import com.google.maps.*;
			import com.google.maps.controls.*;
			import com.google.maps.overlays.*;
			import com.google.maps.styles.*;
			import com.ikanow.infinit.e.actionscript.GoogleMapKMLLoader;
			import com.ikanow.infinit.e.actionscript.InfiniteClusterIcons;
			import com.ikanow.infinit.e.actionscript.InfiniteMapPresentationLayer;
			import com.ikanow.infinit.e.skins.InfiniteFilterApplyOrIgnore;
			import com.ikanow.infinit.e.skins.MapGeoDecayEnable;
			import com.ikanow.infinit.e.skins.MapHeatMapEnable;
			import com.ikanow.infinit.e.skins.MapSelectRegionSkin;
			import com.ikanow.infinit.e.skins.MapToggleDocSkin;
			import com.ikanow.infinit.e.skins.MapToggleEntitySkin;
			import com.ikanow.infinit.e.skins.MapToggleEventSkin;
			import com.ikanow.infinit.e.skins.ZoomModeToggleSkin;
			import mx.collections.ArrayCollection;
			import mx.collections.XMLListCollection;
			import mx.controls.Alert;
			import mx.controls.LinkButton;
			import mx.controls.Menu;
			import mx.events.FlexMouseEvent;
			import mx.events.ItemClickEvent;
			import mx.events.MenuEvent;
			import mx.graphics.SolidColorStroke;
			import mx.managers.PopUpManager;
			import spark.components.BorderContainer;
			import spark.components.Panel;
			import spark.effects.Fade;
			import spark.events.IndexChangeEvent;
			import spark.primitives.Line;
			import flexlib.mdi.containers.MDIWindow;
			import org.alivepdf.colors.RGBColor;
			import org.alivepdf.data.Grid;
			import org.alivepdf.data.GridColumn;
			import org.alivepdf.display.Display;
			import org.alivepdf.fonts.FontFamily;
			import org.alivepdf.fonts.Style;
			import org.alivepdf.images.ImageFormat;
			import org.alivepdf.images.PNGImage;
			import org.alivepdf.images.ResizeMode;
			import org.alivepdf.layout.Align;
			import org.alivepdf.layout.Layout;
			import org.alivepdf.layout.Orientation;
			import org.alivepdf.layout.Size;
			import org.alivepdf.layout.Unit;
			import org.alivepdf.pages.Page;
			import org.alivepdf.pdf.PDF;
			import org.alivepdf.saving.Method;
			import system.data.sets.HashSet;
			
			private static const MAP_OVERLAY:int = 0;
			
			private static const SATTELITE_OVERLAY:int = 1;
			
			private static const TERRAIN_OVERLAY:int = 2;
			
			private static const HYBRID_OVERLAY:int = 3;
			
			public var SHOW_HEAT_MAP:Boolean = true;
			
			public var SHOW_GEO_DOCUMENTS:Boolean = true;
			
			public var SHOW_GEO_ENTITIES:Boolean = true;
			
			public var SHOW_GEO_EVENTS:Boolean = true;
			
			// Determines if filtering results are immediately applied:
			public var ignoreLocalFilter:Boolean = false;
			
			public var internalFilterUpdate:Boolean = false;
			
			public var hasFilter:Boolean = false;
			
			// 3.1.2] Constants
			
			private const API_KEY:String = flash.external.ExternalInterface.call( "getMapLicenseKey" );
			
			// 3.1.3] Bindable parameters / other GUI-specific objects
			
			//(some horrible visualization hackery)			
			private var _mapResizeTimer:Timer = null;
			
			// Heatmap backing data:
			[Bindable]
			private var _heatMapData:XMLListCollection = new XMLListCollection();
			
			// Demo region select state:
			private var _regionSelectMarker:Marker = null;
			
			private var _regionStartLatLng:LatLng = null;
			
			private var _regionEndLatLng:LatLng = null;
			
			private var _regionRadiusSelect:Boolean = false;
			
			private var _regionRadiusDrag:Boolean = false;
			
			private var _regionSelectRadius:Polygon = null;
			
			private var _regionPopUp:BorderContainer = null;
			
			private var _regionOptionPopUp:BorderContainer = null;
			
			private var _regionTimer:Timer;
			
			private var _mouseStart:Point = null;
			
			private var _mouseEnd:Point = null;
			
			//hide markers
			private var _mapMarkerBounds:LatLngBounds = null;
			
			private var _needRecenter:Boolean = false;
			
			//loading last setup
			private var widgetOptions:Object = null;
			
			// 3.1.4] Presentation Layer object
			
			private var _presentationLayer:InfiniteMapPresentationLayer =
				new InfiniteMapPresentationLayer( this as InfiniteMapWidget, this as InfiniteMapWidget );
			
			// setHeatMapAvailable_fromPresentation - Allows the presentation layer to tell the GUI if a heat map can be displayed
			//
			// @param available: whether heat map data is available
			
			// (Some unpleasant state logic to handle the (framework failure?) case where this is set before 
			//  the map is ready...)
			private var _nSavedHeatMapState:int = -1;
			
			private var _kmlData:String = null;
			
			private var _kmlLoader:GoogleMapKMLLoader = null;
			
			private var layersOn:Boolean = false;
			
			private var _layerUrl:Object = null;
			
			private var _ontologyMenu:Menu = null;
			
			// isHeatMapEnabled_fromPresentation - So as to avoid wasiting time in presentation if it's not getting displayed...
			
			public function isHeatMapEnabled_fromPresentation():Boolean
			{
				if ( _nSavedHeatMapState >= 0 )
				{
					SHOW_HEAT_MAP = ( 1 == _nSavedHeatMapState );
					var showOption:Object = _presentationLayer.getShowOptions().getItemAt( 0 ) as Object;
					showOption.toggled = SHOW_HEAT_MAP;
					_heatMapMiddelay.visible = SHOW_HEAT_MAP && ( 1 == _nSavedHeatMapState );
					_nSavedHeatMapState = -1;
				}
				
				return ( _heatMapMiddelay.visible && SHOW_HEAT_MAP );
			}
			
			// Handle Radio Button List of Layers Events and Laod up new Geo Layers
			public function layerSelected( event:ItemClickEvent ):void
			{
				//load the new layer
				_layerUrl = demoKmlLayers.layers.selectedValue;
				loadUrl( _layerUrl.toString() );
			}
			
			// Function to show and hide the layers panel
			// Need to turn into a skin at some point
			public function layersToggleButton_changeHandler( event:Event ):void
			{
				if ( layersOn )
				{
					layersOn = false;
					demoKmlLayers.visible = false;
					layersToggleButton.toolTip = "Show the layers panel";
					_kmlData = null;
					_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
				}
				else
				{
					layersOn = true;
					demoKmlLayers.visible = true;
					layersToggleButton.toolTip = "Hide the layers panel";
					
					if ( null != _layerUrl )
					{
						loadUrl( _layerUrl.toString() );
					}
				}
			}
			
			// Event to load the Kml into the parser
			public function loadKml( event:Event ):void
			{
				_kmlLoader = new GoogleMapKMLLoader( _map, "Google Map Layer" );
				_kmlLoader.showPolygonEdges = true;
				_kmlLoader.opacity = 0.5;  //50% opacity no need for this
				_kmlData = event.target.data;
				
				// Need to re-render markers first (clears other overlays) then this KML:
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
			}
			
			// Load Url of KML file and fire event upon complete to kml parser
			public function loadUrl( url:String ):void
			{
				try
				{
					var loader:URLLoader = new URLLoader();
					loader.addEventListener( Event.COMPLETE, loadKml );
					loader.load( new URLRequest( url ) );
				}
				catch ( e:Error )
				{
					Alert.show( "Error loading layer, check the hostname and URL: " + url );
				}
			}
			
			/**
			 * Allow users to export the widget contents in the specified format
			 * @format filename: the filename+path to which the data will be written (in case it needs to be embedded)
			 * @param format: the format from the "supportedFormats" call
			 *
			 * @returns a ByteArray containing the data to output
			 */
			public function onGenerateExportData( filename:String, format:String ):ByteArray
			{
				var ba:ByteArray = new ByteArray();
				
				switch ( format.toLowerCase() )
				{
					case "kml":
						ba = createKML();
						break;
					default:
						break;
				}
				
				
				return ba;
			}
			/**
			 * function to build a pdf version of the widget
			 *
			 * @return pdf version of the widget
			 */
			public function onGeneratePDF( printPDF:PDF, title:String ):PDF
			{
				var MAX_IMAGE_WIDTH:int = 260;
				var MAX_IMAGE_HEIGHT:int = 190;
				printPDF.addPage( new Page( Orientation.LANDSCAPE, Unit.MM, Size.LETTER ) );
				printPDF.setFont( FontFamily.ARIAL, Style.UNDERLINE, 14 );
				printPDF.writeText( 14, title );
				printPDF.setFont( FontFamily.ARIAL, Style.NORMAL, 12 );
				printPDF.newLine( 10 );
				
				var bitmap:Bitmap = _map.getPrintableBitmap();
				var imageWidth:Number = bitmap.width;
				var imageHeight:Number = bitmap.height;
				
				if ( imageWidth >= imageHeight )
				{
					imageHeight = ( ( imageHeight / imageWidth ) * MAX_IMAGE_WIDTH );
					imageWidth = MAX_IMAGE_WIDTH;
				}
				else
				{
					imageWidth = ( ( imageWidth / imageHeight ) * MAX_IMAGE_HEIGHT );
					imageHeight = MAX_IMAGE_HEIGHT;
				}
				
				
				printPDF.addImage( bitmap, printPDF.getX(), printPDF.getY(), imageWidth, imageHeight, ImageFormat.PNG, 100, 1, ResizeMode.NONE );
				return printPDF;
			}
			
			/**
			 * If a save string has been saved from 'getSaveString' then
			 * when the app gets reloaded the last save string
			 * will be passed to this function.
			 *
			 * @param saveString the last save string or null if there was none
			 */
			public function onLoadWidgetOptions( widgetOptions:Object ):void
			{
				this.widgetOptions = widgetOptions;
			}
			
			/**
			 * function to rescale the module when the parent container is being resized
			 *
			 * @param newHeight The new height the component needs to be set to
			 * @param newWidth The new width the component needs to be set to
			 */
			public function onParentResize( newHeight:Number, newWidth:Number ):void
			{
				this.height = newHeight;
				this.width = newWidth;
				
				if ( null != _mapResizeTimer && !SHOW_HEAT_MAP )
				{ // ie need map to be ready
					// Turn heat map off - it's too slow to redraw
					_heatMapMiddelay.visible = false;
					
					// Start a timer for 100ms time
					this._mapResizeTimer.stop();
					this._mapResizeTimer.start();
				}
			}
			
			/**
			 * This function gets called when the workspace is being saved.
			 * return null if no save string is needed.
			 *
			 * @return a string this widget can use to reload state
			 */
			public function onSaveWidgetOptions():Object
			{
				if ( _map.initialized && _map.isLoaded() )
				{
					widgetOptions = new Object();
					widgetOptions[ "centerLat" ] = _map.getCenter().lat();
					widgetOptions[ "centerLng" ] = _map.getCenter().lng();
					widgetOptions[ "zoomLevel" ] = _map.getZoom();
					return widgetOptions;
				}
				return null;
			}
			
			public function recenterAndZoomMap_fromPresentation( minLat:Number, minLng:Number, maxLat:Number, maxLng:Number, override:Boolean = false ):void
			{
				if ( null == _mapResizeTimer )
				{ // Always auto-zoom if just opened, unless loading last setup
					_mapMarkerBounds = new LatLngBounds( new LatLng( minLat, minLng ), new LatLng( maxLat, maxLng ) );
					_needRecenter = true;
				}
				else
				{
					if ( override || !zoomToggleButton.selected )
					{
						_mapMarkerBounds = new LatLngBounds( new LatLng( minLat, minLng ), new LatLng( maxLat, maxLng ) );
						_needRecenter = true;
					}
				}
			}
			
			// renderHeatMapOverlay_fromPresentation - displays the heatmap if available
			//
			// @param geoArray: an XML list of x,y (pixels) 
			
			public function renderHeatMapOverlay_fromPresentation( geoArray:XMLList ):void
			{
				if ( null == geoArray )
				{
					_heatMapData.removeAll();
					_heatMapMiddelay.visible = false;
				}
				else
				{
					_heatMapData.source = geoArray;
						//(Can't have got here unless heat map visible)
				}
			}
			
			// 3.1.6] Visualization interface
			
			// SUMMARY:
			// renderMapOverlay_fromPresentation(clusteredMarkers, selectedGeolocations):void
			// renderHeatMapOverlay_fromPresentation(geoArray):void
			// setHeatMapAvailable_fromPresentation(available):void
			// isHeatMapEnabled_fromPresentation:Boolean
			
			// renderMapOverlay - displays the clusters generated by the presentation layer
			//
			// @param clusteredMarkers: 
			// @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			
			public function renderMapOverlay_fromPresentation( clusteredMarkers:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				//clear previous markers from map when new data is loaded.
				//after making sure it has been initialized
				if ( _map.initialized && _map.isLoaded() )
				{
					clusterMarkers( clusteredMarkers, selectedGeolocations );
					
					if ( _needRecenter )
						recenterMap();
				}
			}
			
			/**
			 * Resets the ignore local filter flag and button
			 */
			public function resetIgnoreLocalFilter():void
			{
				ignoreLocalFilter = false;
				localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
				localFilterSettings.selected = false;
				localFilterSettings.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
			}
			/** END OVERLAY CODE **/
			
			/**
			 * Resets the sekect region button
			 */
			public function resetSelectRegion():void
			{
				regionSelectToggleButton.toolTip = "Enter region selection mode";
				regionSelectToggleButton.selected = false;
				regionSelectToggleButton.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
			}
			
			public function setHeatMapAvailable_fromPresentation( available:Boolean ):void
			{
				if ( null != _mapResizeTimer )
				{ // (this is one of the last things called when the map is ready)
					_heatMapMiddelay.visible = SHOW_HEAT_MAP && available;
				}
				else
				{
					_nSavedHeatMapState = int( available );
				}
			}
			
			
			/**
			 * @returns A list of supported formats, displayed in a context menu in the format
			 * "Export <string>" - these are called with "generateExportData"
			 * Note this doesn't cover the "built-in" Alive PDF export.
			 * However if the developer specifies PDF and generatePdf() returns non-null then this will be used.
			 */
			
			public function supportedExportFormats():ArrayCollection
			{
				var ac:ArrayCollection = new ArrayCollection();
				ac.addItem( "pdf" );
				ac.addItem( "kml" );
				return ac;
			}
			
			protected function displayTypes_changeHandler( event:IndexChangeEvent ):void
			{
				var displayType:Object = _presentationLayer.getAllowedOntologyTypes().getItemAt( event.newIndex ) as Object;
				displayType.toggled = !displayType.toggled;
				
				//have to redraw data with points changed					
				_presentationLayer.doMapDisplayProcessing();
				
				displayTypes.selectedIndex = -1;
			}
			
			protected function ontologyMenuChangeEvent( event:MenuEvent ):void
			{
				//have to redraw data with points changed					
				_presentationLayer.doMapDisplayProcessing();
			}
			
			protected function showOptions_changeHandler( event:IndexChangeEvent ):void
			{
				var showOption:Object = _presentationLayer.getShowOptions().getItemAt( event.newIndex ) as Object;
				showOption.toggled = !showOption.toggled;
				
				switch ( showOption.data )
				{
					case "heatMap":
					{
						SHOW_HEAT_MAP = showOption.toggled;
						_heatMapMiddelay.visible = SHOW_HEAT_MAP;
						_presentationLayer.heatMapRedraw_fromGUI();
						break;
					}
					case "geoDocuments":
					{
						SHOW_GEO_DOCUMENTS = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
					case "geoEntities":
					{
						SHOW_GEO_ENTITIES = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
					case "geoEvents":
					{
						SHOW_GEO_EVENTS = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
				}
				
				showOptions.selectedIndex = -1;
			}
			
			// Timer to make help disappear
			
			private function _regionTimerTick( event:TimerEvent ):void
			{
				_regionTimer.stop();
				PopUpManager.removePopUp( _regionPopUp );
			}
			
			private function addAllMarkers( markerList:ArrayCollection, maxSize:Number ):void
			{
				for each ( var marker:Object in markerList )
				{
					addMarkers( marker[ "lat" ], marker[ "lon" ], marker[ "size" ], marker[ "alpha" ], marker[ "tooltip" ], marker[ "evtsize" ], maxSize );
				}
				
				// USER OVERLAYS:
				if ( ( null != _kmlData ) && ( null != _kmlLoader ) )
				{
					_kmlLoader.loadKML( _kmlData ); // now render the actual local overlays...
				}
			}
			
			/**
			 * function to add markers to the map based on lat and lon points
			 *
			 * @param lat The latitude of the point
			 * @param lon The longitude of the point
			 * @param markerSize The number of markers at the cluster
			 */
			private function addMarkers( lat:Number, lon:Number, markerSize:Number, alpha:Number, tooltip:String, eventSize:Number = 0, maxSize:Number = 1 ):void
			{
				var markers:Marker;
				
				var opts:MarkerOptions = new MarkerOptions();
				opts.iconAlignment = MarkerOptions.ALIGN_HORIZONTAL_CENTER + MarkerOptions.ALIGN_VERTICAL_CENTER;
				opts.strokeStyle = new StrokeStyle( { color: 0x987654 } );
				opts.fillStyle = new FillStyle( { color: 0x223344, alpha: 0.8 } );
				opts.radius = 12 + markerSize;
				opts.hasShadow = true;
				opts.icon = new InfiniteClusterIcons( markerSize.toString(), eventSize, maxSize );
				opts.icon.alpha = alpha;
				opts.clickable = !regionSelectToggleButton.selected;
				
				if ( regionSelectToggleButton.selected )
				{
					opts.tooltip = tooltip + "\n[Mouse: no action, drag to select region as normal]";
				}
				else
				{
					if ( zoomToggleButton.selected )
					{
						opts.tooltip = tooltip + "\n[Mouse: add docs containing selected entities to filter]";
					}
					else
					{
						opts.tooltip = tooltip + "\n[Mouse: zoom to cluster]";
					}
				}
				
				var textForm:TextFormat = new TextFormat();
				textForm.bold = true;
				textForm.color = 0xFFFFFF;
				opts.labelFormat = textForm;
				
				markers = new Marker( new LatLng( lat, lon ), opts );
				markers.addEventListener( MapMouseEvent.CLICK, onMarkerClick );
				
				// In region select mode, want to treat a marker click exactly like a normal click
				if ( regionSelectToggleButton.selected )
				{
					markers.addEventListener( MapMouseEvent.MOUSE_MOVE, onMapMoveMouse );
					markers.addEventListener( MapMouseEvent.MOUSE_DOWN, onMouseDragStart );
					markers.addEventListener( MapMouseEvent.MOUSE_UP, onMouseDragEnd );
				}
				
				_map.addOverlay( markers );
			}
			
			private function addRegionToGeoDecay( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng ) / 1000; //convert to kilo by /1000
				_presentationLayer.onUpdateQuery_fromGUI( _regionStartLatLng, distance, false );
				optionPopUpLoseFocus( null );
			}
			
			// Region select options:
			
			private function addRegionToQuery( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng ) / 1000; //convert to kilo by /1000
				this.addRegionToQuery_fromPresentation( _regionStartLatLng, distance );
				optionPopUpLoseFocus( null );
			}
			
			private function cancelRegionSelection( event:Event ):void
			{
				optionPopUpLoseFocus( null );
			}
			
			// 3.1.7] Visualization utilities			
			
			/**
			 * function to get clusters to add markers to the map
			 *
			 * @param clusters The array collection of clusters to add to the map
			 * @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			 */
			private function clusterMarkers( clusters:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				_map.clearOverlays();
				var tempMarkerList:ArrayCollection = new ArrayCollection();
				var maxDocCount:Number = 1;
				
				for each ( var group:ArrayCollection in clusters )
				{
					var alpha:Number = ( null == selectedGeolocations ) ? 1.0 : 0.5;
					var feedidSet:HashSet = new HashSet();
					var eventCount:Number = 0;
					var entityCount:Number = 0;
					var docGeoCount:Number = 0;
					
					for each ( var geo:Object in group )
					{
						if ( geo.object_type == "entity" )
						{
							if ( !SHOW_GEO_ENTITIES )
								continue;
							entityCount++;
						}
						else if ( geo.object_type == "docgeo" )
						{
							if ( !SHOW_GEO_DOCUMENTS )
								continue;
							docGeoCount++;
						}
						else
						{
							if ( !SHOW_GEO_EVENTS )
								continue;
							eventCount++;
						}
						feedidSet.add( geo.feed );
						
						if ( ( null != selectedGeolocations ) && selectedGeolocations.contains( geo.index ) )
						{
							alpha = 1.0;
						}
					}
					
					if ( 0 == ( entityCount + docGeoCount + eventCount ) )
					{
						continue; // (only display markers containing something)
					}
					var tempMarker:Object = new Object();
					tempMarker[ "lat" ] = group[ 0 ].geotag.lat;
					tempMarker[ "lon" ] = group[ 0 ].geotag.lon;
					tempMarker[ "size" ] = feedidSet.size();
					tempMarker[ "alpha" ] = alpha;
					tempMarker[ "tooltip" ] = "Documents: " + feedidSet.size() + "\nDocument Geotags: " + docGeoCount + "\nGeotags: " + entityCount + "\nEvents: " + eventCount;
					tempMarker[ "evtsize" ] = eventCount;
					tempMarkerList.addItem( tempMarker );
					
					if ( feedidSet.size() > maxDocCount )
						maxDocCount = feedidSet.size();
				}
				addAllMarkers( tempMarkerList, maxDocCount );
			}
			
			private function createKML():ByteArray
			{
				var xml:String = "<kml xmlns=\"http://www.opengis.net/kml/2.2\"><Document>";
				xml += "<Style id=\"Document\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/wht-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Entity\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Event\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ltblu-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"DocEnt\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href></Icon></IconStyle></Style>";
				
				//var level:int = 20 - _map.getZoom();
				//var range:int = Math.round(Math.pow(2 ,level) * Math.sqrt((_map.width * _map.width) + (_map.height * _map.height)) / 3.3);
				var snip:Number = 26 - _map.getZoom() * Math.log( 2 );
				var range:int = Math.round( Math.pow( 2, snip ) );
				//				var zoom:int = zoom = Math.round(26-(Math.log(range)/Math.log(2)));
				xml += "<LookAt><longitude>" + _map.getCenter().lng() + "</longitude><latitude>" + _map.getCenter().lat() + "</latitude><range>" + range + "</range><tilt>0</tilt></LookAt>";
				
				var feedData:ArrayCollection = _context.getQuery_TopResults().getTopDocuments();
				
				var entityKml:String = "";
				var eventKml:String = "";
				var docKml:String = "";
				var docEntKml:String = "";
				
				for each ( var feed:Object in feedData )
				{
					//loop through the feed to get its entities
					
					for each ( var entity:Object in feed.entities )
					{
						//check to make sure the entity has geotags 
						if ( entity.geotag != null )
						{
							var commonString:String = "<p><b>Entity Type:</b> " + entity.type + "</p>";
							commonString += "<p><b>Document Significance:</b> " + Math.round( Number( entity.significance ) ) + "%</p>";
							commonString += "<p><b>Query Significance:</b> " + Math.round( Number( entity.datasetSignificance ) ) + "%</p>";
							commonString += "<p><b>Relevance:</b> " + ( Math.round( Number( entity.relevance ) * 100 ) ).toPrecision( 2 ) + "%</p>";
							commonString += "<p><b>Frequency:</b> " + entity.frequency + "</p>";
							
							if ( feed.url.substr( 0, 5 ) == "http:" )
							{
								commonString += "<p><b>Url: <b/>" + feed.url + "</p>";
							}
							
							var entVis:String = "";
							
							if ( !SHOW_GEO_ENTITIES )
							{
								entVis += "<visibility>0</visibility>";
							}
							
							
							var entDesc:String = "<![CDATA[";
							entDesc += "<p><b>Feed: " + feed.title + "</b></p>";
							entDesc += commonString;
							entDesc += "\]\]>";
							
							var docEntDesc:String = "<![CDATA[";
							docEntDesc += "<p><b>Entity:</b> " + entity.disambiguated_name + "</p>";
							docEntDesc += commonString;
							docEntDesc += "\]\]>";
							
							
							entityKml += "<Placemark>" + entVis + "<name>Entity: " + entity.disambiguated_name + "</name><description>" + entDesc + "</description><styleUrl>#Entity</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							docEntKml += "<Placemark>" + entVis + "<name>" + feed.title + "</name><description>" + docEntDesc + "</description><styleUrl>#DocEnt</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
						}
					}
					
					//loop through the feed to get its events
					for each ( var event:Object in feed.associations )
					{
						//check to make sure the event has geotags
						if ( event.geotag != null )
						{
							
							var eventDesc:String = "<![CDATA[";
							
							eventDesc += "<p><b>Feed: </b>" + feed.title + "</p>";
							
							if ( event.entity1 != null )
							{
								eventDesc += "<p><b>Entity 1:</b> " + event.entity1 + "</p>";
							}
							
							if ( event.verb != null )
							{
								eventDesc += "<p><b>Verb:</b> " + event.verb + "</p>";
							}
							
							if ( event.entity2 != null )
							{
								eventDesc += "<p><b>Entity 2:</b> " + event.entity2 + "</p>";
							}
							
							var time:String = "";
							
							if ( event.geotag.time_start != null )
							{
								eventDesc += "<p><b>Time Start:</b>" + event.geotag.time_start + "</p>";
								time += "<TimeStamp>" + event.geotag.time_start + "</TimeStamp>";
							}
							
							eventDesc += "\]\]>";
							
							var evtVis:String = "";
							
							if ( !SHOW_GEO_EVENTS )
							{
								evtVis += "<visibility>0</visibility>";
							}
							
							eventKml += "<Placemark>" + evtVis + "<name>Event: " + event.verb_category + "</name>" + time + "<description>" + eventDesc + "</description><styleUrl>#Event</styleUrl>" + "<Point><coordinates>" + event.geotag.lon + "," + event.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							
						}
					}
					
					//get a documents docgeo if it exists
					if ( feed.docGeo != null )
					{
						var docDesc:String = "<![CDATA[";
						
						docDesc += "<p><b>Description: </b>" + feed.description + "</p>";
						
						if ( feed.url.substr( 0, 5 ) == "http:" )
						{
							docDesc += "<p><b>Url: </b>" + feed.url + "</p>";
						}
						
						docDesc += "\]\]>";
						
						var docVis:String = "";
						
						if ( !SHOW_GEO_DOCUMENTS )
						{
							docVis += "<visibility>0</visibility>";
						}
						
						docKml += "<Placemark>" + docVis + "<name>" + feed.title + "</name><description>" + docDesc + "</description><styleUrl>#Document</styleUrl>" + "<Point><coordinates>" + feed.docGeo.lon + "," + feed.docGeo.lat + ",0" + "</coordinates></Point></Placemark>";
					}
				}
				
				
				
				xml += "<Folder><name>Geo-tagged Entities</name>";
				
				if ( !SHOW_GEO_ENTITIES )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += entityKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Documents</name>";
				
				if ( !SHOW_GEO_DOCUMENTS )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += docKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Events</name>";
				
				if ( !SHOW_GEO_EVENTS )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += eventKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Documents Containing Geo-tagged Entities</name>";
				xml += docEntKml;
				xml += "</Folder>";
				
				xml += "</Document></kml>";
				
				var x:XML = new XML( xml );
				
				var ba:ByteArray = new ByteArray();
				ba.writeUTFBytes( x );
				return ba;
			
			}
			
			private function doneResizingMap( event:TimerEvent ):void
			{
				if ( SHOW_HEAT_MAP )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
					
					// For some reason call entire procesing after map finished moving, only heat map after resize?
					_presentationLayer.heatMapRedraw_fromGUI();
				}
			}
			
			/**
			 * Callback to handle the "ignore/allow" local filter button getting pressed
			 */
			private function onClickIgnoreLocalFilter():void
			{
				internalFilterUpdate = true;
				
				this.ignoreLocalFilter = !this.ignoreLocalFilter;
				
				if ( !this.ignoreLocalFilter )
				{
					localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
					_presentationLayer.toggleFilter_fromGUI( hasFilter );
				}
				else
				{
					localFilterSettings.toolTip = "Apply Workspace Filtering - Show Filtered Results";
					_presentationLayer.toggleFilter_fromGUI( false );
				}
				
				internalFilterUpdate = false;
			}
			
			private function onMapFinishedMoving( event:Event ):void
			{
				if ( SHOW_HEAT_MAP )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
				}
				// For some reason call entire procesing after map finished moving, only heat map after resize?
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
				
				_regionSelectMarker = null; // (on zoom, remove the region select marker)
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * Note contained in this viz layer, since it's just a GUI function
			 *
			 * @param event The IndexChangeEvent received when a map type is selected on the tabbar
			 */
			private function onMapMenuItemSelect( event:MenuEvent ):void
			{
				if ( event.index == 0 )
				{
					_map.setMapType( MapType.NORMAL_MAP_TYPE );
				}
				
				if ( event.index == 1 )
				{
					_map.setMapType( MapType.SATELLITE_MAP_TYPE );
				}
				
				if ( event.index == 2 )
				{
					_map.setMapType( MapType.PHYSICAL_MAP_TYPE );
				}
				
				if ( event.index == 3 )
				{
					_map.setMapType( MapType.HYBRID_MAP_TYPE );
				}
			}
			
			private function onMapMoveMouse( event:MapMouseEvent ):void
			{
				if ( _regionRadiusDrag )
				{
					if ( _regionSelectRadius != null )
					{
						_map.removeOverlay( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					var polyOptions:PolygonOptions = new PolygonOptions();
					polyOptions.strokeStyle = new StrokeStyle( { color: 0xFF0000 } );
					polyOptions.fillStyle = new FillStyle( { color: 0xCCCCCC, alpha: 0.5 } );
					
					var polyArray:Array = new Array();
					
					// (need to save this here since onMouseDragEnd can be the wrong lat/long if generated from marker)
					_regionEndLatLng = new LatLng( event.latLng.lat(), event.latLng.lng(), true );
					
					//create an array of 40 points to create a circle around the
					//start point for region
					var distance:Number = _regionStartLatLng.distanceFrom( event.latLng );
					var circlePoints:Number = 40;
					var circleLat:Number = ( distance / 1000 ) * 0.621371192 * 0.014483;
					var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat() * ( Math.PI / 180 ) );
					
					for ( var i:int = 0; i < circlePoints; i++ )
					{
						var theta:Number = Math.PI * ( ( 2 * i ) / circlePoints );
						var pointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
						var pointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
						polyArray.push( new LatLng( pointLat, pointLng, true ) );
					}
					
					_regionSelectRadius = new Polygon( polyArray, polyOptions );
					_map.addOverlay( _regionSelectRadius );
				}
			}
			
			/**
			 * Callback to initialize the map variables when it's done loading
			 *
			 * @param event The Event received when the map is ready
			 */
			private function onMapReady( event:Event ):void
			{
				// Map specific code:
				this._map.key = API_KEY;
				this._map.setCenter( new LatLng( 20.676362, 5.992188 ), 3, MapType.NORMAL_MAP_TYPE );
				this._map.zoomOut( null, true );
				this._map.addControl( new ZoomControl() );
				this._map.addControl( new PositionControl );
				this._map.enableScrollWheelZoom();
				
				// Handle map movement
				this._map.addEventListener( MapMoveEvent.MOVE_START, onMapStartedMoving );
				this._map.addEventListener( MapMoveEvent.MOVE_END, onMapFinishedMoving );
				
				// Handle region selection
				this._map.addEventListener( MapMouseEvent.MOUSE_MOVE, onMapMoveMouse );
				this._map.addEventListener( MapMouseEvent.MOUSE_DOWN, onMouseDragStart );
				this._map.addEventListener( MapMouseEvent.MOUSE_UP, onMouseDragEnd );
				
				this._map.enabled = true;
				this._map.visible = true;
				
				// Timer for heatmap optimization
				_mapResizeTimer = new Timer( 100, 1 ); // (runs once after 100ms)
				_mapResizeTimer.addEventListener( TimerEvent.TIMER_COMPLETE, doneResizingMap );
				
				// KML layers
				
				this.demoKmlLayers.layers.addEventListener( ItemClickEvent.ITEM_CLICK, layerSelected );
				
				// Let the presentation layer know the bounds
				
				_presentationLayer.onMapSizeChanged_fromGUI( _map.getLatLngBounds(), _map.getZoom(), _map );
			}
			/**
			 * Callback to handle the user stopping dragging the mouse (or zooming??)
			 */
			private function onMapStartedMoving( event:Event ):void
			{
				_heatMapMiddelay.visible = false;
				
				//clear any region selecting
				if ( _regionSelectMarker != null )
					_map.removeOverlay( _regionSelectMarker );
				
				if ( _regionSelectRadius != null )
					_map.removeOverlay( _regionSelectRadius );
				_regionSelectRadius = null;
				_regionSelectMarker = null;
				_regionRadiusSelect = false;
				
				// (cancel regions select mode if enabled)
				if ( regionSelectToggleButton.selected )
				{ //first click set marker and await drag end
					optionPopUpLoseFocus( null );
				}
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * (currently: ignore unless it hits a marker)
			 */
			private function onMarkerClick( event:com.google.maps.MapMouseEvent ):void
			{
				// Not if in region selection code
				if ( !regionSelectToggleButton.selected )
				{
					if ( !zoomToggleButton.selected )
					{
						_presentationLayer.onZoomToCluster_fromGUI( event.latLng.lat(), event.latLng.lng() );
					}
					else
					{
						_presentationLayer.onFilterClusterFromLatLong_fromGUI( event.latLng.lat(), event.latLng.lng() );
					}
				}
			}
			
			private function onMouseDragEnd( event:MapMouseEvent ):void
			{
				if ( _regionRadiusSelect ) //if we are done dragging out a region
				{
					_mouseEnd = new Point( _map.mouseX, _map.mouseY );
					
					if ( ( Math.abs( _mouseEnd.x - _mouseStart.x ) > 5 ) || ( Math.abs( _mouseEnd.y - _mouseStart.y ) > 5 ) )
					{
						//prompt user on what they want to do with region:
						_regionRadiusSelect = false;
						_regionRadiusDrag = false;
						showRegionOptionsPopUp();
					}
					else //was a click event, so restart marker drag
					{
						if ( null != _regionSelectMarker )
							_map.removeOverlay( _regionSelectMarker );
						_regionRadiusDrag = false;
						
						if ( _regionSelectRadius != null )
						{
							_map.removeOverlay( _regionSelectRadius );
							_regionSelectRadius = null;
						}
					}
				}
			}
			
			// Dragging in region select mode
			
			private function onMouseDragStart( event:MapMouseEvent ):void
			{
				if ( _regionRadiusSelect ) //first click set marker and await drag end
				{
					_mouseStart = new Point( _map.mouseX, _map.mouseY );
					_map.setFocus();
					
					if ( null != _regionSelectMarker )
						_map.removeOverlay( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
					{
						_map.removeOverlay( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					_regionSelectMarker = new Marker( event.latLng );
					_map.addOverlay( _regionSelectMarker );
					_regionStartLatLng = event.latLng;
					_regionRadiusDrag = true;
				}
			}
			
			// 3.1.5] Callbacks
			
			/**
			 * Method fired when module is done loading.  Sends
			 * message to parent letting it know that module is
			 * ready to receive data.
			 */
			private function onWidgetCreationComplete():void
			{
			
			}
			
			// Handles selecting an option
			
			private function optionPopUpLoseFocus( event:FlexMouseEvent ):void
			{
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				if ( _regionOptionPopUp != null )
				{
					_regionOptionPopUp.removeEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
					PopUpManager.removePopUp( _regionOptionPopUp );
				}
				
				if ( event == null || event.relatedObject != regionSelectToggleButton )
				{
					resetSelectRegion();
					regionSelectToggleButton_changeHandler();
					_map.enableDragging();
				}
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * Note contained in this viz layer, since it's just a GUI function
			 *
			 * @param event The IndexChangeEvent received when a map type is selected on the tabbar
			 */
			private function overlayOptions_changeHandler( event:IndexChangeEvent ):void
			{
				if ( event.newIndex == MAP_OVERLAY )
				{
					_map.setMapType( MapType.NORMAL_MAP_TYPE );
				}
				
				if ( event.newIndex == SATTELITE_OVERLAY )
				{
					_map.setMapType( MapType.SATELLITE_MAP_TYPE );
				}
				
				if ( event.newIndex == TERRAIN_OVERLAY )
				{
					_map.setMapType( MapType.PHYSICAL_MAP_TYPE );
				}
				
				if ( event.newIndex == HYBRID_OVERLAY )
				{
					_map.setMapType( MapType.HYBRID_MAP_TYPE );
				}
			}
			
			private function recenterMap():void
			{
				if ( _map.initialized && _map.isLoaded() && _mapMarkerBounds != null )
				{
					_needRecenter = false;
					
					if ( widgetOptions != null )
					{
						_map.setCenter( new LatLng( widgetOptions.centerLat, widgetOptions.centerLng ), widgetOptions.zoomLevel, MapType.NORMAL_MAP_TYPE );
						widgetOptions = null;
					}
					else
					{
						var zoomLevel:Number = _map.getBoundsZoomLevel( _mapMarkerBounds )
						var centerPoint:LatLng = _mapMarkerBounds.getCenter();
						_map.setCenter( centerPoint, zoomLevel );
					}
				}
			}
			/**
			 * Callback to start/stop region selection mode
			 */
			private function regionSelectToggleButton_changeHandler( event:Event = null ):void
			{
				if ( !regionSelectToggleButton.selected )
				{ // Leaving region selection mode
					
					_map.enableDragging();
					regionSelectToggleButton.toolTip = "Enter region selection mode";
					
					if ( _regionSelectMarker != null )
						_map.removeOverlay( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
						_map.removeOverlay( _regionSelectRadius );
					_regionSelectRadius = null;
					_regionSelectMarker = null;
					_regionRadiusSelect = false;
				}
				else
				{ // Entering region selection mode
					regionSelectToggleButton.toolTip = "Leave region selection mode (will lose any selected regions)";
					//display message prompting user to click/drag
					showRegionSelectPopUp();
					_regionRadiusSelect = true;
					
					_map.disableDragging();
				}
				// Redraw the clusters with clickability on/off
				_presentationLayer.doMapDisplayProcessing();
			}
			
			// (options)
			
			private function showRegionOptionsPopUp():void
			{
				//create it
				if ( _regionOptionPopUp == null )
				{
					var sepVGroup1:VGroup = new VGroup();
					sepVGroup1.horizontalAlign = "center";
					sepVGroup1.verticalAlign = "middle";
					sepVGroup1.percentHeight = 100;
					sepVGroup1.percentWidth = 100;
					var seperator1:Line = new Line();
					seperator1.percentWidth = 90;
					seperator1.yFrom = 1;
					seperator1.yTo = 1;
					seperator1.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup1.addElement( seperator1 );
					
					var sepVGroup2:VGroup = new VGroup();
					sepVGroup2.horizontalAlign = "center";
					sepVGroup2.verticalAlign = "middle";
					sepVGroup2.percentHeight = 100;
					sepVGroup2.percentWidth = 100;
					var seperator2:Line = new Line();
					seperator2.percentWidth = 90;
					seperator2.yFrom = 1;
					seperator2.yTo = 1;
					seperator2.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup2.addElement( seperator2 );
					
					var link1:LinkButton = new LinkButton();
					link1.label = "Add region to query";
					link1.addEventListener( "click", addRegionToQuery );
					
					var link2:LinkButton = new LinkButton();
					link2.label = "Set region as geo decay";
					link2.addEventListener( "click", addRegionToGeoDecay );
					
					var link3:LinkButton = new LinkButton();
					link3.label = "Zoom to region";
					link3.addEventListener( "click", zoomToRegion );
					
					var linkCancel:LinkButton = new LinkButton();
					linkCancel.label = "Cancel region selection";
					linkCancel.addEventListener( "click", cancelRegionSelection );
					
					var vg:VGroup = new VGroup();
					vg.verticalAlign = "middle";
					vg.horizontalAlign = "left";
					vg.percentHeight = 100;
					vg.percentWidth = 100;
					vg.addElement( link1 );
					vg.addElement( link2 );
					vg.addElement( sepVGroup1 );
					vg.addElement( link3 );
					vg.addElement( sepVGroup2 );
					vg.addElement( linkCancel );
					_regionOptionPopUp = new BorderContainer();
					_regionOptionPopUp.alpha = 1;
					_regionOptionPopUp.setStyle( "paddingBottom", 2 );
					_regionOptionPopUp.setStyle( "paddingTop", 2 );
					_regionOptionPopUp.setStyle( "paddingLeft", 2 );
					_regionOptionPopUp.setStyle( "paddingRight", 2 );
					_regionOptionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionOptionPopUp.setStyle( "cornerRadius", 5 );
					_regionOptionPopUp.percentWidth = 100;
					_regionOptionPopUp.percentHeight = 100;
					_regionOptionPopUp.addElement( vg );
				}
				//then show it
				var popupX:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.x : this.parent.parent.parent.x;
				var popupY:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.y : this.parent.parent.parent.y + 60;
				_regionOptionPopUp.x = popupX + _mouseEnd.x;
				_regionOptionPopUp.y = popupY + _mouseEnd.y;
				
				// (remove other popup)
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				// show this pop up
				PopUpManager.removePopUp( _regionOptionPopUp );
				PopUpManager.addPopUp( _regionOptionPopUp, this, false );
				PopUpManager.bringToFront( _regionOptionPopUp );
				
				_regionOptionPopUp.setFocus();
				_regionOptionPopUp.addEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
			}
			
			//
			// Lots of region selection logic:
			//
			
			// Pop ups
			
			// (help)
			
			private function showRegionSelectPopUp():void
			{
				//create the popup if needbe
				if ( _regionPopUp == null )
				{
					var label:Label = new Label();
					label.text = "Click a location and drag to select a region";
					var hg:HGroup = new HGroup();
					hg.verticalAlign = "middle";
					hg.horizontalAlign = "center";
					hg.percentHeight = 100;
					hg.percentWidth = 100;
					hg.addElement( label );
					_regionPopUp = new BorderContainer();
					_regionPopUp.alpha = 1;
					_regionPopUp.setStyle( "paddingBottom", 2 );
					_regionPopUp.setStyle( "paddingTop", 2 );
					_regionPopUp.setStyle( "paddingLeft", 2 );
					_regionPopUp.setStyle( "paddingRight", 2 );
					_regionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionPopUp.setStyle( "cornerRadius", 5 );
					_regionPopUp.width = 320;
					_regionPopUp.height = 40;
					_regionPopUp.addElement( hg );
					
					_regionTimer = new Timer( 4000 );
					_regionTimer.addEventListener( TimerEvent.TIMER, _regionTimerTick );
				}
				
				//then show it
				PopUpManager.removePopUp( _regionPopUp );
				PopUpManager.addPopUp( _regionPopUp, this, false );
				PopUpManager.centerPopUp( _regionPopUp );
				_regionTimer.stop();
				_regionTimer.start();
			}
			
			private function zoomToRegion( event:Event ):void
			{
				optionPopUpLoseFocus( null );
				
				var distance:Number = _regionStartLatLng.distanceFrom( _regionEndLatLng );
				var circleLat:Number = ( distance / 1000 ) * 0.621371192 * 0.014483;
				var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat() * ( Math.PI / 180 ) );
				var theta:Number = Math.PI / 4;
				//CALC NE Point (45 degrees i.e. pi/4
				
				var nepointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
				var nepointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
				
				//CALC SW Point (5pi/4)
				theta = 5 * Math.PI / 4;
				var swpointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
				var swpointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
				
				//create bounds from points and zoom to that
				var bounds:LatLngBounds = new LatLngBounds( new LatLng( swpointLat, swpointLng ), new LatLng( nepointLat, nepointLng ) );
				_map.setCenter( bounds.getCenter(), _map.getBoundsZoomLevel( bounds ) );
			
			}
			
			// Other callback code
			
			private function zoomToggleButton_changeHandler( event:Event ):void
			{
				if ( zoomToggleButton.selected )
				{
					zoomToggleButton.toolTip = "Enter click-to-zoom mode/leave click-to-filter mode (and re-enable auto-zoom)";
				}
				else
				{
					zoomToggleButton.toolTip = "Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
		]]>
	</fx:Script>

	<!-- Ideally this should be a separate object to enforce encapsulation between the Model
	and Visualization layers. Will worry about how to do this if the experiment is otherwise
	a success-->

	<fx:Script source="com/ikanow/infinit/e/actionscript/InfiniteMapModelLayer.as" />
</components:WidgetModule>
